<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy Map Explorer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: #1a1a1a;
            color: #ecf0f1;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        .game-container {
            position: relative;
            height: 100vh;
            width: 100vw;
        }

        #map {
            height: 100vh;
            width: 100vw;
            z-index: 1;
        }

        /* Floating UI Panels */
        .ui-panel {
            position: absolute;
            background: rgba(44, 62, 80, 0.95);
            backdrop-filter: blur(10px);
            border: 2px solid #f39c12;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .ui-panel.collapsed {
            opacity: 0.7;
            transform: scale(0.95);
        }

        .ui-panel:hover {
            opacity: 1;
            transform: scale(1);
        }

        /* Character Panel - Top Left */
        .character-panel {
            top: 20px;
            left: 20px;
            width: 280px;
            max-height: 400px;
            overflow-y: auto;
        }

        /* Travel Status - Top Right */
        .travel-status {
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(46, 204, 113, 0.95);
            border-color: #2ecc71;
            display: none;
        }

        /* Event Log - Bottom Left */
        .event-log {
            bottom: 20px;
            left: 20px;
            width: 320px;
            max-height: 250px;
            background: rgba(142, 68, 173, 0.95);
            border-color: #9b59b6;
        }

        /* Instructions Panel - Bottom Right */
        .instructions {
            bottom: 20px;
            right: 20px;
            width: 280px;
            background: rgba(52, 152, 219, 0.95);
            border-color: #3498db;
        }

        /* Unified UI Panel Styling */
        .unified-ui-panel {
            position: absolute; /* Or fixed, depending on desired behavior with map scroll */
            top: 10px;
            left: 10px;
            width: 320px; /* Or desired width */
            max-height: calc(100vh - 20px); /* Adjust based on top/bottom margin */
            background: rgba(44, 62, 80, 0.95); /* Similar to existing panels */
            backdrop-filter: blur(10px);
            border: 2px solid #f39c12;
            border-radius: 15px;
            padding: 0; /* Padding will be handled by tab content or header */
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            z-index: 1000; /* Ensure it's above the map */
            display: flex; /* Use flex to arrange tab bar and content */
            flex-direction: column;
            overflow: hidden; /* Prevent content from spilling out before scroll is implemented */
        }

        /* Tab Bar Styling */
        .tab-bar {
            display: flex;
            justify-content: space-around; /* Or space-between, or flex-start */
            align-items: center;
            background: rgba(30, 40, 50, 0.8); /* Slightly darker or different from panel bg */
            padding: 5px 0;
            border-bottom: 1px solid #f39c12;
            flex-shrink: 0; /* Prevent tab bar from shrinking */
        }

        /* Tab Button Styling */
        .tab-button {
            background: none;
            border: none;
            color: #ecf0f1;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 1.1em; /* Adjust as needed for emojis later */
            transition: background 0.2s ease, color 0.2s ease;
            border-radius: 5px; /* Optional: for rounded hover effect */
        }

        .tab-button:hover {
            background: rgba(243, 156, 18, 0.2);
            color: #f39c12;
        }

        .tab-button.active { /* Style for the active tab */
            background: rgba(243, 156, 18, 0.3);
            color: #f39c12;
            font-weight: bold;
        }

        /* Tab Content Styling */
        .tab-content {
            display: none; /* Hidden by default, JS will show the active one */
            padding: 15px;
            overflow-y: auto; /* Allow scrolling for content that exceeds panel height */
            flex-grow: 1; /* Allow content to take available space */
            /* max-height will be implicitly handled by .unified-ui-panel's max-height and flex layout */
        }

        /* Ensure any direct children of tab-content that were previously panel-content divs reset their margins if necessary */
        .tab-content > .panel-content {
            margin: 0; /* Reset margin if it was part of the old .panel-content styling */
            padding: 0; /* Reset padding if it was part of the old .panel-content styling */
        }
        
        /* Styling for specific content moved from panels, if needed to override old styles */
        #characterTabContent .stat-row { /* Example if stat-row needs adjustment in new layout */
            /* Add specific overrides if necessary */
        }
        #inventoryTabContent {
          /* Styles for inventory items might need to be checked */
        }
        #eventLogTabContent .event-entry {
          /* Styles for event entries might need to be checked */
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .ui-panel {
                position: fixed;
                max-width: calc(100vw - 40px);
                font-size: 0.9em;
            }

            .character-panel {
                top: 10px;
                left: 10px;
                right: 10px;
                width: auto;
                max-height: 200px;
            }

            .travel-status {
                top: 10px;
                left: 10px;
                right: 10px;
                width: auto;
            }

            .event-log {
                bottom: 10px;
                left: 10px;
                right: 10px;
                width: auto;
                max-height: 150px;
            }

            .instructions {
                bottom: 170px;
                left: 10px;
                right: 10px;
                width: auto;
            }
        }

        /* Collapsible Panel Headers */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
            user-select: none;
        }

        .panel-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #f39c12;
        }

        .collapse-btn {
            background: none;
            border: none;
            color: #f39c12;
            font-size: 1.2em;
            cursor: pointer;
            padding: 5px;
            border-radius: 3px;
            transition: background 0.2s ease;
        }

        .collapse-btn:hover {
            background: rgba(243, 156, 18, 0.2);
        }

        .panel-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .panel-content.collapsed {
            max-height: 0;
            opacity: 0;
            padding: 0;
            margin: 0;
        }

        .character-panel {
            background: rgba(52, 73, 94, 0.9);
            border: 2px solid #f39c12;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .character-name {
            font-size: 1.3em;
            color: #f39c12;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            padding: 4px 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 5px;
            font-size: 0.9em;
        }

        .stat-label {
            font-weight: bold;
            color: #bdc3c7;
        }

        .stat-value {
            color: #f39c12;
            font-weight: bold;
        }

        .travel-status {
            background: rgba(46, 204, 113, 0.2);
            border: 2px solid #2ecc71;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .travel-status h3 {
            color: #2ecc71;
            margin-bottom: 10px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2ecc71, #27ae60);
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .event-log {
            background: rgba(142, 68, 173, 0.2);
            border: 2px solid #9b59b6;
            border-radius: 10px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .event-log h3 {
            color: #9b59b6;
            margin-bottom: 10px;
        }

        .event-entry {
            background: rgba(0,0,0,0.3);
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            font-size: 0.9em;
            border-left: 3px solid #9b59b6;
        }

        .event-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .event-content {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            border: 3px solid #f39c12;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center;
        }

        .event-title {
            font-size: 1.6em;
            color: #f39c12;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .event-description {
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 20px;
            color: #ecf0f1;
        }

        .event-choices {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .choice-btn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .choice-btn:hover {
            background: linear-gradient(135deg, #c0392b, #a93226);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .login-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #2c3e50, #34495e);
            border: 3px solid #f39c12;
            border-radius: 15px;
            padding: 30px;
            z-index: 10001;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .login-panel h2 {
            color: #f39c12;
            margin-bottom: 20px;
        }

        .login-panel input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 2px solid #34495e;
            border-radius: 5px;
            background: rgba(52, 73, 94, 0.5);
            color: #ecf0f1;
            font-size: 1em;
        }

        .login-panel input:focus {
            outline: none;
            border-color: #f39c12;
        }

        .login-btn {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            margin: 10px 5px;
            transition: all 0.3s ease;
        }

        .login-btn:hover {
            background: linear-gradient(135deg, #e67e22, #d35400);
            transform: translateY(-2px);
        }

        .character-marker {
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, #f39c12, #e67e22);
            border: 3px solid #2c3e50;
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(243, 156, 18, 0.8);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 15px rgba(243, 156, 18, 0.8); }
            50% { box-shadow: 0 0 25px rgba(243, 156, 18, 1); }
            100% { box-shadow: 0 0 15px rgba(243, 156, 18, 0.8); }
        }

        .destination-marker {
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #e74c3c, #c0392b);
            border: 2px solid #fff;
            border-radius: 50%;
            animation: bounce 1s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        .instructions {
            background: rgba(52, 152, 219, 0.2);
            border: 2px solid #3498db;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        .instructions h4 {
            color: #3498db;
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="login-panel" id="loginPanel">
        <h2>🗡️ Enter the Realm 🗡️</h2>
        <input type="text" id="usernameInput" placeholder="Enter your adventurer name" maxlength="20">
        <br>
        <label for="spawnLocationInput">Choose Starting Area:</label>
        <input type="text" id="spawnLocationInput" placeholder="Enter desired spawn location (e.g., forest, mountains)" style="width: 100%; padding: 10px; margin: 10px 0; border: 2px solid #34495e; border-radius: 5px; background: rgba(52, 73, 94, 0.5); color: #ecf0f1; font-size: 1em;">
        <button class="login-btn" onclick="createCharacter()">Begin Adventure</button>
        <button class="login-btn" onclick="loadCharacter()">Continue Journey</button>
    </div>

    <div class="game-container" id="gameContainer" style="display: none;">
        <div id="map"></div>

        <div id="unifiedUIPanel" class="ui-panel unified-ui-panel">
            <div class="tab-bar">
                <button class="tab-button" data-tab="character">⚔️</button>
                <button class="tab-button" data-tab="inventory">🎒</button>
                <button class="tab-button" data-tab="pets">🐾</button> 
                <button class="tab-button" data-tab="eventLog">📜</button>
                <button class="tab-button" data-tab="instructions">🗺️</button>
            </div>
            <div id="characterTabContent" class="tab-content">
                <div class="character-name" id="characterName">Adventurer</div>
                <div class="stat-row">
                    <span class="stat-label">🏃 Speed:</span>
                    <span class="stat-value" id="speedStat">10</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">⚔️ Combat:</span>
                    <span class="stat-value" id="combatStat">10</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">🧙 Magic:</span>
                    <span class="stat-value" id="magicStat">10</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">🍀 Luck:</span>
                    <span class="stat-value" id="luckStat">10</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">💰 Gold:</span>
                    <span class="stat-value" id="goldStat">50</span>
                </div>
            </div>
            <div id="inventoryTabContent" class="tab-content">
                <div class="panel-content" id="inventoryContent">
                <!-- Inventory items will be listed here -->
                <div class="inventory-item">No items yet.</div>
            </div>
            </div>
            <div id="eventLogTabContent" class="tab-content">
                <div class="panel-content" id="eventLogContent">
                <div class="event-entry">Welcome to the mystical realm! Click on the map to begin your journey.</div>
            </div>
            </div>
            <div id="instructionsTabContent" class="tab-content">
                <p>Click anywhere on the map to set your destination. Your character will travel there, encountering various events along the way!</p>
            </div>
            <div id="petsTabContent" class="tab-content">
                <!-- Acquired pets will be listed here by JavaScript -->
            </div>
        </div>
        
        <!-- Character Panel - Top Left -->
        <div class="ui-panel character-panel" style="display: none;">
            <div class="panel-header" onclick="togglePanel(this)">
                <div class="panel-title">⚔️ Character</div>
                <button class="collapse-btn">−</button>
            </div>
            <div class="panel-content">
                
            </div>
        </div>

        <!-- Inventory Panel - e.g., Below Character Panel -->
        <div class="ui-panel inventory-panel" style="top: 440px; left: 20px; width: 280px; max-height: 200px; display: none;">
            <div class="panel-header" onclick="togglePanel(this)">
                <div class="panel-title">🎒 Inventory</div>
                <button class="collapse-btn">−</button>
            </div>
            <div class="panel-content" id="inventoryContent_original">
                
            </div>
        </div>

        <!-- Travel Status - Top Right -->
        <div class="ui-panel travel-status" id="travelStatus" style="display: none;">
            <div class="panel-header" onclick="togglePanel(this)">
                <div class="panel-title">🚶 Journey</div>
                <button class="collapse-btn">−</button>
            </div>
            <div class="panel-content">
                <div id="travelInfo">Ready to adventure!</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <button class="choice-btn" onclick="cancelTravel()" style="margin-top: 8px; padding: 8px 16px; font-size: 0.9em;">Cancel Journey</button>
            </div>
        </div>

        <!-- Instructions - Bottom Right -->
        <div class="ui-panel instructions" style="display: none;">
            <div class="panel-header" onclick="togglePanel(this)">
                <div class="panel-title">🗺️ Controls</div>
                <button class="collapse-btn">−</button>
            </div>
            <div class="panel-content">
                
            </div>
        </div>

        <!-- Event Log - Bottom Left -->
        <div class="ui-panel event-log" style="display: none;">
            <div class="panel-header" onclick="togglePanel(this)">
                <div class="panel-title">📜 Adventure Log</div>
                <button class="collapse-btn">−</button>
            </div>
            <div class="panel-content" id="eventLogContent_original">
                
            </div>
        </div>
    </div>

    <div class="event-modal" id="eventModal">
        <div class="event-content">
            <div class="event-title" id="eventTitle">Random Encounter</div>
            <div class="event-description" id="eventDescription">Something interesting happens...</div>
            <div class="event-choices" id="eventChoices"></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script type="module">
        // Firebase Configuration (Mock implementation for demo)
        class MockFirebase {
            constructor() {
                this.data = JSON.parse(localStorage.getItem('gameData') || '{}');
            }

            async saveCharacter(username, character) {
                this.data[username] = character;
                localStorage.setItem('gameData', JSON.stringify(this.data));
                return true;
            }

            async loadCharacter(username) {
                return this.data[username] || null;
            }

            async logEvent(username, event) {
                if (!this.data[username]) return;
                if (!this.data[username].eventLog) this.data[username].eventLog = [];
                this.data[username].eventLog.push({
                    timestamp: Date.now(),
                    event: event
                });
                localStorage.setItem('gameData', JSON.stringify(this.data));
            }
        }

        const firebase = new MockFirebase();

        // Game State
        let gameState = {
            currentUser: null,
            character: null,
            map: null,
            currentPosition: [51.505, -0.09], // London default
            destination: null,
            isMoving: false,
            moveInterval: null,
            characterMarker: null,
            destinationMarker: null
        };

        // Event Templates
        const eventTemplates = [
            {
                title: "Bandit Ambush!",
                description: "A group of bandits blocks your path, demanding your gold!",
                choices: [
                    { text: "Fight them! (Combat)", stat: 'combat', success: "You defeat the bandits and find 20 gold!", fail: "You barely escape, losing 10 gold.", reward: 20, penalty: -10 },
                    { text: "Try to sneak past (Luck)", stat: 'luck', success: "You slip by unnoticed!", fail: "They spot you and you lose 5 gold in the scuffle.", reward: 0, penalty: -5 },
                    { text: "Pay them off", stat: null, success: "They let you pass for 15 gold.", fail: "", reward: 0, penalty: -15 }
                ]
            },
            {
                title: "Mystical Shrine",
                description: "You discover an ancient shrine glowing with magical energy.",
                choices: [
                    { text: "Touch the shrine (Magic)", stat: 'magic', success: "The shrine blesses you! +2 Magic permanently!", fail: "The magic backfires, draining your energy.", reward: 0, penalty: 0, statBonus: { magic: 2 } },
                    { text: "Search around it (Luck)", stat: 'luck', success: "You find a hidden cache with 30 gold!", fail: "You find nothing of value.", reward: 30, penalty: 0 },
                    { text: "Leave it alone", stat: null, success: "You continue your journey safely.", fail: "", reward: 0, penalty: 0 }
                ]
            },
            {
                title: "Traveling Merchant",
                description: "A friendly merchant offers to trade with you.",
                choices: [
                    { text: "Buy speed boots (30 gold)", stat: null, success: "Your speed increases by 3!", fail: "", reward: 0, penalty: -30, statBonus: { speed: 3 }, goldCost: 30 },
                    { text: "Buy lucky charm (25 gold)", stat: null, success: "Your luck increases by 2!", fail: "", reward: 0, penalty: -25, statBonus: { luck: 2 }, goldCost: 25 },
                    { text: "Just chat", stat: null, success: "The merchant shares wisdom about the road ahead.", fail: "", reward: 0, penalty: 0 }
                ]
            },
            {
                title: "Wild Storm",
                description: "Dark clouds gather and a fierce storm begins!",
                choices: [
                    { text: "Push through (Speed)", stat: 'speed', success: "You outrun the storm!", fail: "You get caught in the rain and feel sluggish.", reward: 0, penalty: 0 },
                    { text: "Seek shelter (Luck)", stat: 'luck', success: "You find a cozy inn and rest well!", fail: "You huddle under a tree, getting soaked.", reward: 0, penalty: 0 },
                    { text: "Use magic protection", stat: 'magic', success: "Your magical barrier keeps you dry!", fail: "Your spell fails and you're drenched.", reward: 0, penalty: 0 }
                ]
            },
            {
                title: "Ancient Ruins",
                description: "You stumble upon mysterious ancient ruins with strange markings.",
                choices: [
                    { text: "Investigate carefully", stat: 'magic', success: "You decipher ancient magic and gain power! +1 to all stats!", fail: "The ruins collapse partially, but you escape.", reward: 0, penalty: 0, statBonus: { speed: 1, combat: 1, magic: 1, luck: 1 } },
                    { text: "Search for treasure", stat: 'luck', success: "You find an ancient coin worth 40 gold!", fail: "You trigger a trap but escape unharmed.", reward: 40, penalty: 0 },
                    { text: "Leave immediately", stat: null, success: "You wisely avoid any potential danger.", fail: "", reward: 0, penalty: 0 }
                ]
            },
            {
                title: "Forgotten Backpack",
                description: "You find a dusty old backpack tucked away in a small alcove. It seems to have something inside.",
                choices: [
                    { text: "Open it carefully", stat: 'luck', success: "Inside, you find a 'Mystic Compass'!", fail: "It's empty, just cobwebs.", reward: 0, penalty: 0, item: "Mystic Compass" },
                    { text: "Leave it, might be trapped", stat: null, success: "You decide to leave it undisturbed.", fail: "", reward: 0, penalty: 0 }
                ]
            },
            {
                title: "A Lost Creature",
                description: "You come across a small, lost wolf pup whimpering in the bushes. It looks hungry but wary.",
                choices: [
                    {
                        text: "Offer some food and try to befriend it (Luck 7+)",
                        stat: 'luck', // Requires a luck check
                        success: "The pup cautiously approaches and accepts your offering. It seems to trust you! You've gained a companion!",
                        fail: "The pup gets scared and runs away into the undergrowth.",
                        reward: 0, // No gold reward/penalty
                        penalty: 0,
                        action: function(character) { // Custom action for success
                            if (!character.pets) character.pets = [];
                            // Simple naming for now, could be made more dynamic later
                            const petName = "Wolf Pup"; 
                            character.pets.push({ 
                                id: 'pet_' + Date.now(), // Simple unique ID
                                type: "Wolf", 
                                name: petName 
                            });
                            return `You named your new companion ${petName}.`; // This message can be appended to the main success message
                        }
                    },
                    {
                        text: "Leave it be.",
                        stat: null,
                        success: "You decide to leave the creature to its fate.",
                        fail: "",
                        reward: 0,
                        penalty: 0
                    }
                ]
            }
        ];

        // Toggle panel collapse
        window.togglePanel = function(header) {
            const content = header.nextElementSibling;
            const button = header.querySelector('.collapse-btn');
            const panel = header.parentElement;
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                button.textContent = '−';
                panel.classList.remove('collapsed');
            } else {
                content.classList.add('collapsed');
                button.textContent = '+';
                panel.classList.add('collapsed');
            }
        };

        // Initialize map
        function initMap() {
            gameState.map = L.map('map', {
                zoomControl: false // Remove default zoom controls
            }).setView(gameState.currentPosition, 18);
            
            // Add zoom control to bottom right
            L.control.zoom({
                position: 'bottomleft'
            }).addTo(gameState.map);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(gameState.map);

            // Add character marker
            const characterIcon = L.divIcon({
                className: 'character-marker',
                iconSize: [30, 30]
            });
            
            gameState.characterMarker = L.marker(gameState.currentPosition, { icon: characterIcon })
                .addTo(gameState.map)
                .bindPopup("🧙‍♂️ " + gameState.character.name);

            // Handle map clicks
            gameState.map.on('click', function(e) {
                if (!gameState.isMoving) {
                    setDestination(e.latlng);
                }
            });
        }

        // Set destination and start movement
        function setDestination(latlng) {
            gameState.destination = [latlng.lat, latlng.lng];
            
            // Remove old destination marker
            if (gameState.destinationMarker) {
                gameState.map.removeLayer(gameState.destinationMarker);
            }
            
            // Add new destination marker
            const destIcon = L.divIcon({
                className: 'destination-marker',
                iconSize: [20, 20]
            });
            
            gameState.destinationMarker = L.marker(gameState.destination, { icon: destIcon })
                .addTo(gameState.map)
                .bindPopup("🎯 Destination");

            startMovement();
        }

        // Calculate distance between two points
        function calculateDistance(pos1, pos2) {
            const R = 6371000; // Earth's radius in m
            const dLat = (pos2[0] - pos1[0]) * Math.PI / 180;
            const dLon = (pos2[1] - pos1[1]) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(pos1[0] * Math.PI / 180) * Math.cos(pos2[0] * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Start character movement
        function startMovement() {
            if (gameState.isMoving) return;
            
            gameState.isMoving = true;
            document.getElementById('travelStatus').style.display = 'block';
            
            // Store journey data in gameState for resuming
            gameState.journeyData = {
                startPosition: [...gameState.currentPosition],
                totalDistance: calculateDistance(gameState.currentPosition, gameState.destination),
                distanceTraveled: 0,
                eventCounter: 0
            };
            
            const baseSpeed = gameState.character.speed * 2; // Convert to m per step (original speed was km/step, now m/step)
            
            updateTravelInfo(gameState.journeyData.totalDistance, gameState.journeyData.distanceTraveled);
            
            gameState.moveInterval = setInterval(() => {
                const stepDistance = Math.min(baseSpeed, gameState.journeyData.totalDistance - gameState.journeyData.distanceTraveled);
                
                // Calculate new position based on original journey
                const progress = (gameState.journeyData.distanceTraveled + stepDistance) / gameState.journeyData.totalDistance;
                const newLat = gameState.journeyData.startPosition[0] + (gameState.destination[0] - gameState.journeyData.startPosition[0]) * progress;
                const newLng = gameState.journeyData.startPosition[1] + (gameState.destination[1] - gameState.journeyData.startPosition[1]) * progress;
                
                gameState.characterMarker.setLatLng([newLat, newLng]);
                gameState.journeyData.distanceTraveled += stepDistance;
                
                updateTravelInfo(gameState.journeyData.totalDistance, gameState.journeyData.distanceTraveled);
                
                // Check for events
                gameState.journeyData.eventCounter++;
                if (gameState.journeyData.eventCounter >= Math.max(3, Math.floor(20 / gameState.character.speed)) && Math.random() < 0.4) {
                    gameState.journeyData.eventCounter = 0;
                    pauseMovement();
                    triggerRandomEvent();
                    return;
                }
                
                // Check if destination reached
                if (gameState.journeyData.distanceTraveled >= gameState.journeyData.totalDistance) {
                    completeMovement();
                }
            }, 1000);
        }

        // Update travel information display
        function updateTravelInfo(totalDistance, distanceTraveled) {
            const progress = (distanceTraveled / totalDistance) * 100;
            document.getElementById('travelInfo').textContent = 
                `Distance: ${distanceTraveled.toFixed(0)}/${totalDistance.toFixed(0)} m`;
            document.getElementById('progressFill').style.width = progress + '%';
        }

        // Pause movement (for events)
        function pauseMovement() {
            if (gameState.moveInterval) {
                clearInterval(gameState.moveInterval);
                gameState.moveInterval = null;
            }
        }

        // Resume movement after event
        function resumeMovement() {
            if (gameState.isMoving && !gameState.moveInterval && gameState.destination && gameState.journeyData) {
                const baseSpeed = gameState.character.speed * 2; // Convert to m per step (original speed was km/step, now m/step)
                
                gameState.moveInterval = setInterval(() => {
                    const stepDistance = Math.min(baseSpeed, gameState.journeyData.totalDistance - gameState.journeyData.distanceTraveled);
                    
                    // Calculate new position based on original journey
                    const progress = (gameState.journeyData.distanceTraveled + stepDistance) / gameState.journeyData.totalDistance;
                    const newLat = gameState.journeyData.startPosition[0] + (gameState.destination[0] - gameState.journeyData.startPosition[0]) * progress;
                    const newLng = gameState.journeyData.startPosition[1] + (gameState.destination[1] - gameState.journeyData.startPosition[1]) * progress;
                    
                    gameState.characterMarker.setLatLng([newLat, newLng]);
                    gameState.journeyData.distanceTraveled += stepDistance;
                    
                    updateTravelInfo(gameState.journeyData.totalDistance, gameState.journeyData.distanceTraveled);
                    
                    // Check for events
                    gameState.journeyData.eventCounter++;
                    if (gameState.journeyData.eventCounter >= Math.max(3, Math.floor(20 / gameState.character.speed)) && Math.random() < 0.4) {
                        gameState.journeyData.eventCounter = 0;
                        pauseMovement();
                        triggerRandomEvent();
                        return;
                    }
                    
                    // Check if destination reached
                    if (gameState.journeyData.distanceTraveled >= gameState.journeyData.totalDistance) {
                        completeMovement();
                    }
                }, 1000);
            }
        }

        // Complete movement
        function completeMovement() {
            gameState.isMoving = false;
            pauseMovement();
            
            // Update current position
            gameState.currentPosition = [...gameState.destination];
            gameState.destination = null;
            gameState.journeyData = null; // Clear journey data
            
            // Remove destination marker
            if (gameState.destinationMarker) {
                gameState.map.removeLayer(gameState.destinationMarker);
                gameState.destinationMarker = null;
            }
            
            document.getElementById('travelStatus').style.display = 'none';
            addEventLog("🎯 Reached your destination! Click somewhere new to continue exploring.");
            
            saveCharacterData();
        }

        // Cancel travel
        window.cancelTravel = function() {
            gameState.isMoving = false;
            pauseMovement();
            
            if (gameState.destinationMarker) {
                gameState.map.removeLayer(gameState.destinationMarker);
                gameState.destinationMarker = null;
            }
            
            gameState.destination = null;
            gameState.journeyData = null; // Clear journey data
            document.getElementById('travelStatus').style.display = 'none';
            addEventLog("🛑 Journey cancelled. Ready for a new adventure!");
        };

        // Trigger random event
        function triggerRandomEvent() {
            const event = eventTemplates[Math.floor(Math.random() * eventTemplates.length)];
            showEventModal(event);
        }

        // Show event modal
        function showEventModal(event) {
            document.getElementById('eventTitle').textContent = event.title;
            document.getElementById('eventDescription').textContent = event.description;
            
            const choicesContainer = document.getElementById('eventChoices');
            choicesContainer.innerHTML = '';
            
            event.choices.forEach((choice, index) => {
                const button = document.createElement('button');
                button.className = 'choice-btn';
                button.textContent = choice.text;
                button.onclick = () => handleEventChoice(event, choice);
                choicesContainer.appendChild(button);
            });
            
            document.getElementById('eventModal').style.display = 'flex';
        }

        // Handle event choice
        function handleEventChoice(event, choice) {
            let result = choice.success;
            let goldChange = choice.reward || 0;
            
            // Check if choice requires a stat check
            if (choice.stat) {
                const statValue = gameState.character[choice.stat];
                const difficulty = 10 + Math.floor(Math.random() * 10);
                const roll = Math.floor(Math.random() * 20) + 1;
                
                if (roll + statValue < difficulty) {
                    result = choice.fail || "Nothing happens.";
                    goldChange = choice.penalty || 0;
                }
            } else if (choice.goldCost) {
                if (gameState.character.gold < choice.goldCost) {
                    result = "You don't have enough gold!";
                    goldChange = 0;
                } else {
                    goldChange = -choice.goldCost;
                }
            }
            
            // Apply gold changes
            if (goldChange !== 0) {
                gameState.character.gold = Math.max(0, gameState.character.gold + goldChange);
                updateCharacterDisplay();
            }
            
            // Apply stat bonuses
            if (choice.statBonus && goldChange >= 0) {
                Object.keys(choice.statBonus).forEach(stat => {
                    gameState.character[stat] += choice.statBonus[stat];
                });
                updateCharacterDisplay();
            }
            
            // Apply stat bonuses
            if (choice.statBonus && goldChange >= 0) { // Also ensure goldChange wasn't a penalty that negated the bonus condition
                Object.keys(choice.statBonus).forEach(stat => {
                    gameState.character[stat] += choice.statBonus[stat];
                });
                updateCharacterDisplay();
            }

            // Check for item grant
            if (choice.item && result === choice.success) { // Item is granted if choice has an item and the outcome was successful
                if (!gameState.character.inventory) { // Defensive check
                    gameState.character.inventory = [];
                }
                gameState.character.inventory.push(choice.item);
                updateInventoryDisplay(); // Update the inventory UI
                // Add to the event log message that an item was found.
                // The 'result' variable already holds the main success message.
                result += ` You obtained: ${choice.item}!`; 
            }

            // Handle custom action for successful choices (like acquiring a pet)
            let actionMessage = "";
            if (result === choice.success) { // Check if the outcome was the defined success message for this choice
                if (typeof choice.action === 'function') {
                    const petMessage = choice.action(gameState.character);
                    if (petMessage) {
                        actionMessage = " " + petMessage; // Add a space before appending
                    }
                }
                // The pet should be added, now update pet display if the tab exists
                // This function doesn't exist yet, but we're preparing for it.
                // if (document.getElementById('petsTabContent')) { 
                //    if (typeof updatePetDisplay === 'function') updatePetDisplay();
                // }
            }
            result += actionMessage; // Append action message to the overall result
            
            addEventLog(`⚔️ ${event.title}: ${result}`);
            document.getElementById('eventModal').style.display = 'none';
            
            saveCharacterData();

            // Call updatePetDisplay here after a pet might have been added.
            // This function will be created in the next step.
            if (typeof window.updatePetDisplay === 'function') {
                window.updatePetDisplay();
            }
            
            if (gameState.isMoving) {
                resumeMovement();
            }
        }

        // Add event to log
        function addEventLog(message) {
            const logContainer = document.getElementById('eventLogContent');
            const entry = document.createElement('div');
            entry.className = 'event-entry';
            entry.textContent = message;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            // Keep only last 10 entries
            while (logContainer.children.length > 10) {
                logContainer.removeChild(logContainer.firstChild);
            }
        }

        // Update character display
        function updateCharacterDisplay() {
            document.getElementById('characterName').textContent = gameState.character.name;
            document.getElementById('speedStat').textContent = gameState.character.speed;
            document.getElementById('combatStat').textContent = gameState.character.combat;
            document.getElementById('magicStat').textContent = gameState.character.magic;
            document.getElementById('luckStat').textContent = gameState.character.luck;
            document.getElementById('goldStat').textContent = gameState.character.gold;
        }

        // Save character data
        async function saveCharacterData() {
            if (gameState.currentUser && gameState.character) {
                gameState.character.position = gameState.currentPosition;
                await firebase.saveCharacter(gameState.currentUser, gameState.character);
            }
        }

        // Create new character
        window.createCharacter = async function() {
            const username = document.getElementById('usernameInput').value.trim();
            if (!username) {
                alert('Please enter a character name!');
                return;
            }
            
            gameState.currentUser = username;
            
            const spawnInput = document.getElementById('spawnLocationInput').value.trim().toLowerCase();
            // const spawnPoints = {
            //     random: null, // Will be handled by random logic
            //     forest: [51.520, -0.100], // Example coordinates
            //     mountains: [51.480, -0.050], // Example coordinates
            //     coast: [51.500, -0.150], // Example coordinates
            //     london: [51.505, -0.09] // Default
            // };

            let startPosition;
            const predefinedLocations = {
                "london": [51.505, -0.09],
                "whispering forest": [51.520, -0.100], // Matched to old "forest"
                "dragon's peak": [51.480, -0.050],   // Matched to old "mountains"
                "serene coastline": [51.500, -0.150] // Matched to old "coast"
            };

            let spawnMessage = "";

            if (predefinedLocations[spawnInput]) {
                startPosition = predefinedLocations[spawnInput];
                spawnMessage = `Spawning you in ${document.getElementById('spawnLocationInput').value.trim()}.`;
            } else if (spawnInput === "random" || spawnInput === "") {
                // Simple random within a box around London for now
                startPosition = [
                    parseFloat((Math.random() * (51.55 - 51.45) + 51.45).toFixed(5)),
                    parseFloat((Math.random() * (-0.04 - (-0.14)) + (-0.14)).toFixed(5))
                ];
                spawnMessage = "Spawning you at a random location.";
            } else {
                // Default to random if input is not recognized
                startPosition = [
                    parseFloat((Math.random() * (51.55 - 51.45) + 51.45).toFixed(5)),
                    parseFloat((Math.random() * (-0.04 - (-0.14)) + (-0.14)).toFixed(5))
                ];
                spawnMessage = `Could not find "${document.getElementById('spawnLocationInput').value.trim()}". Spawning you at a random location instead.`;
            }
            
            gameState.character = {
                name: username,
                speed: 8 + Math.floor(Math.random() * 5),
                combat: 8 + Math.floor(Math.random() * 5),
                magic: 8 + Math.floor(Math.random() * 5),
                luck: 8 + Math.floor(Math.random() * 5),
                gold: 50,
                position: startPosition, // Use the chosen/random position
                inventory: [], // <-- New inventory array
                pets: [] // <-- Add this line
            };
            
            gameState.currentPosition = gameState.character.position;
            
            await saveCharacterData();
            addEventLog(spawnMessage); // Add spawn message to event log
            startGame();
        };

        // Load existing character
        window.loadCharacter = async function() {
            const username = document.getElementById('usernameInput').value.trim();
            if (!username) {
                alert('Please enter your character name!');
                return;
            }
            
            const character = await firebase.loadCharacter(username);
            if (!character) {
                alert('Character not found! Try creating a new one.');
                return;
            }
            
            gameState.currentUser = username;
            // Ensure inventory is initialized for older save formats
            if (!character.inventory) {
                character.inventory = [];
            }
            // Ensure pets array is initialized for older save formats
            if (!character.pets) {
                character.pets = [];
            }
            gameState.character = character;
            gameState.currentPosition = character.position || [51.505, -0.09];
            
            startGame();
        };

        // Start the game
        function startGame() {
            document.getElementById('loginPanel').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'flex';
            
            updateCharacterDisplay();
            initMap();
            
            addEventLog(`🌟 Welcome back, ${gameState.character.name}! Your adventure continues...`);
            updateInventoryDisplay(); // <-- Call new function
            window.openTab('character'); // Open Character tab by default

            window.updatePetDisplay(); // <-- Add this call
        }

        // Function to update the inventory display
        function updateInventoryDisplay() {
            const inventoryContent = document.getElementById('inventoryContent');
            if (!inventoryContent) { // Add a guard clause in case this is called before the element is in the new tab
                console.warn("updateInventoryDisplay called but inventoryContent not found");
                return;
            }
            inventoryContent.innerHTML = ''; // Clear current display

            if (gameState.character && gameState.character.inventory && gameState.character.inventory.length > 0) {
                gameState.character.inventory.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'inventory-item';
                    // Assuming item is a string for now. If it's an object, use item.name or similar.
                    itemDiv.textContent = item; 
                    inventoryContent.appendChild(itemDiv);
                });
            } else {
                const noItemsDiv = document.createElement('div');
                noItemsDiv.className = 'inventory-item';
                noItemsDiv.textContent = 'No items yet.';
                inventoryContent.appendChild(noItemsDiv);
            }
        }

        // Initialize game on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Game starts with login panel visible

            const tabButtons = document.querySelectorAll('#unifiedUIPanel .tab-button');
            tabButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const tabName = this.getAttribute('data-tab');
                    window.openTab(tabName);
                });
            });
        });

        window.openTab = function(tabBaseName) {
           // Hide all tab content
           const tabContents = document.querySelectorAll('#unifiedUIPanel .tab-content'); // Scope query to unified panel
           tabContents.forEach(content => {
               content.style.display = 'none';
           });

           // Deactivate all tab buttons
           const tabButtons = document.querySelectorAll('#unifiedUIPanel .tab-button'); // Scope query to unified panel
           tabButtons.forEach(button => {
               button.classList.remove('active');
           });

           // Show the selected tab content
           const selectedTabContentId = tabBaseName + "TabContent";
           const selectedTabContent = document.getElementById(selectedTabContentId);
           if (selectedTabContent) {
               selectedTabContent.style.display = 'block';
           }

           // Activate the selected tab button
           const activeButton = document.querySelector(`.tab-button[data-tab='${tabBaseName}']`);
           if (activeButton) {
               activeButton.classList.add('active');
           }
       }

       window.updatePetDisplay = function() {
           const petsContent = document.getElementById('petsTabContent');
           if (!petsContent) return; // Exit if the pets tab content area isn't found

           petsContent.innerHTML = ''; // Clear previous pet list

           if (gameState.character && gameState.character.pets && gameState.character.pets.length > 0) {
               const petList = document.createElement('ul');
               petList.style.listStyleType = 'none'; // Optional: remove bullets
               petList.style.padding = '0';

               gameState.character.pets.forEach(pet => {
                   const petItem = document.createElement('li');
                   petItem.style.padding = '5px 0';
                   petItem.style.borderBottom = '1px solid #444'; // Optional: separator

                   // Display pet icon based on type (simple emojis for now)
                   let petIcon = '❓'; // Default icon
                   if (pet.type.toLowerCase() === 'wolf') {
                       petIcon = '🐺';
                   } else if (pet.type.toLowerCase() === 'bear') {
                       petIcon = '🐻';
                   } else if (pet.type.toLowerCase() === 'goblin') {
                       petIcon = '👺';
                   }
                   
                   petItem.textContent = `${petIcon} ${pet.name} (${pet.type})`;
                   petList.appendChild(petItem);
               });
               petsContent.appendChild(petList);
           } else {
               petsContent.innerHTML = '<p>No loyal companions by your side... yet!</p>';
           }
       }
    </script>
</body>
</html>
