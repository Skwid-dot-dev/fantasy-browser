<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy Map Explorer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: #1a1a1a;
            color: #ecf0f1;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        .game-container {
            position: relative;
            height: 100vh;
            width: 100vw;
        }

        #map {
            height: 100vh;
            width: 100vw;
            z-index: 1;
        }

        /* Floating UI Panels */
        .ui-panel {
            position: absolute;
            background: rgba(44, 62, 80, 0.95);
            backdrop-filter: blur(10px);
            border: 2px solid #f39c12;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .ui-panel.collapsed {
            opacity: 0.7;
            transform: scale(0.95);
        }

        .ui-panel:hover {
            opacity: 1;
            transform: scale(1);
        }

        /* Character Panel - Top Left */
        .character-panel {
            top: 20px;
            left: 20px;
            width: 280px;
            max-height: 400px;
            overflow-y: auto;
        }

        /* Travel Status - Top Right */
        .travel-status {
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(46, 204, 113, 0.95);
            border-color: #2ecc71;
            display: none;
        }

        /* Event Log - Bottom Left */
        .event-log {
            bottom: 20px;
            left: 20px;
            width: 320px;
            max-height: 250px;
            background: rgba(142, 68, 173, 0.95);
            border-color: #9b59b6;
        }

        /* Instructions Panel - Bottom Right */
        .instructions {
            bottom: 20px;
            right: 20px;
            width: 280px;
            background: rgba(52, 152, 219, 0.95);
            border-color: #3498db;
        }

        /* Unified UI Panel Styling */
        .unified-ui-panel {
            position: absolute; /* Or fixed, depending on desired behavior with map scroll */
            top: 10px;
            left: 10px;
            width: 320px; /* Or desired width */
            max-height: calc(100vh - 20px); /* Adjust based on top/bottom margin */
            background: rgba(44, 62, 80, 0.95); /* Similar to existing panels */
            backdrop-filter: blur(10px);
            border: 2px solid #f39c12;
            border-radius: 15px;
            padding: 0; /* Padding will be handled by tab content or header */
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            z-index: 1000; /* Ensure it's above the map */
            display: flex; /* Use flex to arrange tab bar and content */
            flex-direction: column;
            overflow: hidden; /* Prevent content from spilling out before scroll is implemented */
        }

        /* Tab Bar Styling */
        .tab-bar {
            display: flex;
            justify-content: space-around; /* Or space-between, or flex-start */
            align-items: center;
            background: rgba(30, 40, 50, 0.8); /* Slightly darker or different from panel bg */
            padding: 5px 0;
            border-bottom: 1px solid #f39c12;
            flex-shrink: 0; /* Prevent tab bar from shrinking */
        }

        /* Tab Button Styling */
        .tab-button {
            background: none;
            border: none;
            color: #ecf0f1;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 1.1em; /* Adjust as needed for emojis later */
            transition: background 0.2s ease, color 0.2s ease;
            border-radius: 5px; /* Optional: for rounded hover effect */
        }

        .tab-button:hover {
            background: rgba(243, 156, 18, 0.2);
            color: #f39c12;
        }

        .tab-button.active { /* Style for the active tab */
            background: rgba(243, 156, 18, 0.3);
            color: #f39c12;
            font-weight: bold;
        }

        /* Tab Content Styling */
        .tab-content {
            display: none; /* Hidden by default, JS will show the active one */
            padding: 15px;
            overflow-y: auto; /* Allow scrolling for content that exceeds panel height */
            flex-grow: 1; /* Allow content to take available space */
            /* max-height will be implicitly handled by .unified-ui-panel's max-height and flex layout */
        }

        /* Ensure any direct children of tab-content that were previously panel-content divs reset their margins if necessary */
        .tab-content > .panel-content {
            margin: 0; /* Reset margin if it was part of the old .panel-content styling */
            padding: 0; /* Reset padding if it was part of the old .panel-content styling */
        }
        
        /* Styling for specific content moved from panels, if needed to override old styles */
        #characterTabContent .stat-row { /* Example if stat-row needs adjustment in new layout */
            /* Add specific overrides if necessary */
        }
        #inventoryTabContent {
          /* Styles for inventory items might need to be checked */
        }
        #eventLogTabContent .event-entry {
          /* Styles for event entries might need to be checked */
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .ui-panel {
                position: fixed;
                max-width: calc(100vw - 40px);
                font-size: 0.9em;
            }

            .character-panel {
                top: 10px;
                left: 10px;
                right: 10px;
                width: auto;
                max-height: 200px;
            }

            .travel-status {
                top: 10px;
                left: 10px;
                right: 10px;
                width: auto;
            }

            .event-log {
                bottom: 10px;
                left: 10px;
                right: 10px;
                width: auto;
                max-height: 150px;
            }

            .instructions {
                bottom: 170px;
                left: 10px;
                right: 10px;
                width: auto;
            }
        }

        /* Collapsible Panel Headers */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
            user-select: none;
        }

        .panel-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #f39c12;
        }

        .collapse-btn {
            background: none;
            border: none;
            color: #f39c12;
            font-size: 1.2em;
            cursor: pointer;
            padding: 5px;
            border-radius: 3px;
            transition: background 0.2s ease;
        }

        .collapse-btn:hover {
            background: rgba(243, 156, 18, 0.2);
        }

        .panel-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .panel-content.collapsed {
            max-height: 0;
            opacity: 0;
            padding: 0;
            margin: 0;
        }

        .character-panel {
            background: rgba(52, 73, 94, 0.9);
            border: 2px solid #f39c12;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .character-name {
            font-size: 1.3em;
            color: #f39c12;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            padding: 4px 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 5px;
            font-size: 0.9em;
        }

        .stat-label {
            font-weight: bold;
            color: #bdc3c7;
        }

        .stat-value {
            color: #f39c12;
            font-weight: bold;
        }

        .travel-status {
            background: rgba(46, 204, 113, 0.2);
            border: 2px solid #2ecc71;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .travel-status h3 {
            color: #2ecc71;
            margin-bottom: 10px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2ecc71, #27ae60);
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .event-log {
            background: rgba(142, 68, 173, 0.2);
            border: 2px solid #9b59b6;
            border-radius: 10px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .event-log h3 {
            color: #9b59b6;
            margin-bottom: 10px;
        }

        .event-entry {
            background: rgba(0,0,0,0.3);
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            font-size: 0.9em;
            border-left: 3px solid #9b59b6;
        }

        .event-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .event-content {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            border: 3px solid #f39c12;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center;
        }

        .event-title {
            font-size: 1.6em;
            color: #f39c12;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .event-description {
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 20px;
            color: #ecf0f1;
        }

        .event-choices {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .choice-btn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .choice-btn:hover {
            background: linear-gradient(135deg, #c0392b, #a93226);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .login-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #2c3e50, #34495e);
            border: 3px solid #f39c12;
            border-radius: 15px;
            padding: 30px;
            z-index: 10001;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .login-panel h2 {
            color: #f39c12;
            margin-bottom: 20px;
        }

        .login-panel input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 2px solid #34495e;
            border-radius: 5px;
            background: rgba(52, 73, 94, 0.5);
            color: #ecf0f1;
            font-size: 1em;
        }

        .login-panel input:focus {
            outline: none;
            border-color: #f39c12;
        }

        .login-btn {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            margin: 10px 5px;
            transition: all 0.3s ease;
        }

        .login-btn:hover {
            background: linear-gradient(135deg, #e67e22, #d35400);
            transform: translateY(-2px);
        }

        .character-marker {
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, #f39c12, #e67e22);
            border: 3px solid #2c3e50;
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(243, 156, 18, 0.8);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 15px rgba(243, 156, 18, 0.8); }
            50% { box-shadow: 0 0 25px rgba(243, 156, 18, 1); }
            100% { box-shadow: 0 0 15px rgba(243, 156, 18, 0.8); }
        }

        .destination-marker {
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #e74c3c, #c0392b);
            border: 2px solid #fff;
            border-radius: 50%;
            animation: bounce 1s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        .instructions {
            background: rgba(52, 152, 219, 0.2);
            border: 2px solid #3498db;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        .instructions h4 {
            color: #3498db;
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="login-panel" id="loginPanel">
        <h2>🗡️ Enter the Realm 🗡️</h2>
        <input type="text" id="usernameInput" placeholder="Enter your adventurer name" maxlength="20">
        <br>
        <label for="spawnLocationInput">Choose Starting Area:</label>
        <input type="text" id="spawnLocationInput" placeholder="e.g., forest, mountains, or a real address like 'Spartanburg SC'" style="width: 100%; padding: 10px; margin: 10px 0; border: 2px solid #34495e; border-radius: 5px; background: rgba(52, 73, 94, 0.5); color: #ecf0f1; font-size: 1em;">
        <button class="login-btn" onclick="createCharacter()">Begin Adventure</button>
        <button class="login-btn" onclick="loadCharacter()">Continue Journey</button>
    </div>

    <div class="game-container" id="gameContainer" style="display: none;">
        <div id="map"></div>

        <div id="unifiedUIPanel" class="ui-panel unified-ui-panel">
            <div class="tab-bar">
                <button class="tab-button" data-tab="character">⚔️</button>
                <button class="tab-button" data-tab="inventory">🎒</button>
                <button class="tab-button" data-tab="pets">🐾</button> 
                <button class="tab-button" data-tab="eventLog">📜</button>
                <button class="tab-button" data-tab="instructions">🗺️</button>
                <button class="tab-button" onclick="window.logoutCharacter()">🚪</button>
            </div>
            <div id="characterTabContent" class="tab-content">
                <div class="character-name" id="characterName">Adventurer</div>
                <div class="stat-row">
                    <span class="stat-label">🏃 Speed:</span>
                    <span class="stat-value" id="speedStat">10</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">⚔️ Combat:</span>
                    <span class="stat-value" id="combatStat">10</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">🧙 Magic:</span>
                    <span class="stat-value" id="magicStat">10</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">🍀 Luck:</span>
                    <span class="stat-value" id="luckStat">10</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">💰 Gold:</span>
                    <span class="stat-value" id="goldStat">50</span>
                </div>
                <hr style="border-top: 1px solid #f39c12; margin: 10px 0;"> <!-- Visual separator -->
                <div class="stat-row">
                    <span class="stat-label">🌲 Woodcutting:</span>
                    <span class="stat-value" id="woodcuttingStat">1</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">⛏️ Mining:</span>
                    <span class="stat-value" id="miningStat">1</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">🎣 Fishing:</span>
                    <span class="stat-value" id="fishingStat">1</span>
                </div>
            </div>
            <div id="inventoryTabContent" class="tab-content">
                <div class="panel-content" id="inventoryContent">
                <!-- Inventory items will be listed here -->
                <div class="inventory-item">No items yet.</div>
            </div>
            </div>
            <div id="eventLogTabContent" class="tab-content">
                <div class="panel-content" id="eventLogContent">
                <div class="event-entry">Welcome to the mystical realm! Click on the map to begin your journey.</div>
            </div>
            </div>
            <div id="instructionsTabContent" class="tab-content">
                <p>Click anywhere on the map to set your destination. Your character will travel there, encountering various events along the way!</p>
            </div>
            <div id="petsTabContent" class="tab-content">
                <!-- Acquired pets will be listed here by JavaScript -->
            </div>
        </div>
        
        <!-- Character Panel - Top Left -->
        <div class="ui-panel character-panel" style="display: none;">
            <div class="panel-header" onclick="togglePanel(this)">
                <div class="panel-title">⚔️ Character</div>
                <button class="collapse-btn">−</button>
            </div>
            <div class="panel-content">
                
            </div>
        </div>

        <!-- Inventory Panel - e.g., Below Character Panel -->
        <div class="ui-panel inventory-panel" style="top: 440px; left: 20px; width: 280px; max-height: 200px; display: none;">
            <div class="panel-header" onclick="togglePanel(this)">
                <div class="panel-title">🎒 Inventory</div>
                <button class="collapse-btn">−</button>
            </div>
            <div class="panel-content" id="inventoryContent_original">
                
            </div>
        </div>

        <!-- Travel Status - Top Right -->
        <div class="ui-panel travel-status" id="travelStatus" style="display: none;">
            <div class="panel-header" onclick="togglePanel(this)">
                <div class="panel-title">🚶 Journey</div>
                <button class="collapse-btn">−</button>
            </div>
            <div class="panel-content">
                <div id="travelInfo">Ready to adventure!</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <button class="choice-btn" onclick="cancelTravel()" style="margin-top: 8px; padding: 8px 16px; font-size: 0.9em;">Cancel Journey</button>
            </div>
        </div>

        <!-- Instructions - Bottom Right -->
        <div class="ui-panel instructions" style="display: none;">
            <div class="panel-header" onclick="togglePanel(this)">
                <div class="panel-title">🗺️ Controls</div>
                <button class="collapse-btn">−</button>
            </div>
            <div class="panel-content">
                
            </div>
        </div>

        <!-- Event Log - Bottom Left -->
        <div class="ui-panel event-log" style="display: none;">
            <div class="panel-header" onclick="togglePanel(this)">
                <div class="panel-title">📜 Adventure Log</div>
                <button class="collapse-btn">−</button>
            </div>
            <div class="panel-content" id="eventLogContent_original">
                
            </div>
        </div>
    </div>

    <div class="event-modal" id="eventModal">
        <div class="event-content">
            <div class="event-title" id="eventTitle">Random Encounter</div>
            <div class="event-description" id="eventDescription">Something interesting happens...</div>
            <div class="event-choices" id="eventChoices"></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script type="module">
      // Import the functions you need from the SDKs you need
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-app.js";
      import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-analytics.js";
      import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-auth.js";
      import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-firestore.js";

      // Your web app's Firebase configuration
      // For Firebase JS SDK v7.20.0 and later, measurementId is optional
      const firebaseConfig = {
        apiKey: "AIzaSyDFuK9Tf89hwAG7L_is8NY00kn-Y44E8Qg",
        authDomain: "fantasy-browser-5de23.firebaseapp.com",
        projectId: "fantasy-browser-5de23",
        storageBucket: "fantasy-browser-5de23.firebasestorage.app",
        messagingSenderId: "976083957249",
        appId: "1:976083957249:web:720073a57c62074df0b200",
        measurementId: "G-SYQLZKXBRG"
      };

      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const analytics = getAnalytics(app);
      const auth = getAuth(app);
      const db = getFirestore(app);

      // Make them accessible globally if needed by other parts of your script
      window.auth = auth;
      window.db = db;
      window.firebase = {
          saveCharacter: async (characterData) => { // Removed username parameter
              if (!window.auth.currentUser) {
                  console.error("User not logged in. Cannot save character.");
                  alert("Error: You are not logged in. Cannot save character.");
                  return Promise.reject("User not logged in");
              }
              const uid = window.auth.currentUser.uid;
              const userDocRef = doc(db, "characters", uid); // Use UID for document ID
              try {
                  await setDoc(userDocRef, characterData);
                  console.log("Character saved for UID:", uid);
                  return true;
              } catch (error) {
                  console.error("Error saving character for UID:", uid, error);
                  alert("Error saving character data: " + error.message);
                  return Promise.reject(error);
              }
          },
          loadCharacter: async () => { // Removed username parameter
              if (!window.auth.currentUser) {
                  console.error("User not logged in. Cannot load character.");
                  // No alert here, as this might be called speculatively.
                  // The calling function (window.loadCharacter) will handle user feedback.
                  return Promise.resolve(null); // Resolve with null if not logged in
              }
              const uid = window.auth.currentUser.uid;
              const userDocRef = doc(db, "characters", uid); // Use UID for document ID
              try {
                  const docSnap = await getDoc(userDocRef);
                  if (docSnap.exists()) {
                      console.log("Character data loaded for UID:", uid);
                      return docSnap.data();
                  } else {
                      console.log("No character document found for UID:", uid);
                      return null;
                  }
              } catch (error) {
                  console.error("Error loading character for UID:", uid, error);
                  alert("Error loading character data: " + error.message);
                  return Promise.resolve(null); // Resolve with null on error
              }
          },
          logEvent: async (event) => { // Username parameter removed, assumes UID from auth.currentUser
            if (!window.auth.currentUser) {
                console.warn("Event log attempted without logged in user.");
                return;
            }
            const uid = window.auth.currentUser.uid;
            // This function is not fully implemented to save to Firestore yet.
            // You might want to save events to a subcollection in the character's document.
            console.log("Event logged for UID (locally, not to Firestore yet):", uid, event);
          }
      };

    </script>
    <script type="module">
        // IMPORTANT DEVELOPMENT NOTE:
        // The current authentication uses a fixed password ("password123") and derives
        // the email from the username (username + "@example.com").
        // This is INSECURE and for DEVELOPMENT TESTING ONLY.
        // For a production system, you MUST implement proper password handling and
        // ideally use real email addresses for account creation and recovery.

        // Game State
        let gameState = {
            currentUser: null,
            character: null,
            map: null,
            currentPosition: [51.505, -0.09], // London default
            destination: null,
            isMoving: false,
            moveInterval: null,
            characterMarker: null,
            destinationMarker: null,
            currentTerrainType: 'plains' // Default initial terrain
        };

        // Event Templates
        const eventTemplates = [
            {
                title: "Bandit Ambush!",
                description: "A group of bandits blocks your path, demanding your gold!",
                choices: [
                    { text: "Fight them! (Combat)", stat: 'combat', success: "You defeat the bandits and find 20 gold!", fail: "You barely escape, losing 10 gold.", reward: 20, penalty: -10 },
                    { text: "Try to sneak past (Luck)", stat: 'luck', success: "You slip by unnoticed!", fail: "They spot you and you lose 5 gold in the scuffle.", reward: 0, penalty: -5 },
                    { text: "Pay them off", stat: null, success: "They let you pass for 15 gold.", fail: "", reward: 0, penalty: -15 }
                ]
            },
            {
                title: "Mystical Shrine",
                description: "You discover an ancient shrine glowing with magical energy.",
                choices: [
                    { text: "Touch the shrine (Magic)", stat: 'magic', success: "The shrine blesses you! +2 Magic permanently!", fail: "The magic backfires, draining your energy.", reward: 0, penalty: 0, statBonus: { magic: 2 } },
                    { text: "Search around it (Luck)", stat: 'luck', success: "You find a hidden cache with 30 gold!", fail: "You find nothing of value.", reward: 30, penalty: 0 },
                    { text: "Leave it alone", stat: null, success: "You continue your journey safely.", fail: "", reward: 0, penalty: 0 }
                ]
            },
            {
                title: "Traveling Merchant",
                description: "A friendly merchant offers to trade with you.",
                choices: [
                    { text: "Buy speed boots (30 gold)", stat: null, success: "Your speed increases by 3!", fail: "", reward: 0, penalty: -30, statBonus: { speed: 3 }, goldCost: 30 },
                    { text: "Buy lucky charm (25 gold)", stat: null, success: "Your luck increases by 2!", fail: "", reward: 0, penalty: -25, statBonus: { luck: 2 }, goldCost: 25 },
                    { text: "Just chat", stat: null, success: "The merchant shares wisdom about the road ahead.", fail: "", reward: 0, penalty: 0 }
                ]
            },
            {
                title: "Wild Storm",
                description: "Dark clouds gather and a fierce storm begins!",
                choices: [
                    { text: "Push through (Speed)", stat: 'speed', success: "You outrun the storm!", fail: "You get caught in the rain and feel sluggish.", reward: 0, penalty: 0 },
                    { text: "Seek shelter (Luck)", stat: 'luck', success: "You find a cozy inn and rest well!", fail: "You huddle under a tree, getting soaked.", reward: 0, penalty: 0 },
                    { text: "Use magic protection", stat: 'magic', success: "Your magical barrier keeps you dry!", fail: "Your spell fails and you're drenched.", reward: 0, penalty: 0 }
                ]
            },
            {
                title: "Ancient Ruins",
                description: "You stumble upon mysterious ancient ruins with strange markings.",
                choices: [
                    { text: "Investigate carefully", stat: 'magic', success: "You decipher ancient magic and gain power! +1 to all stats!", fail: "The ruins collapse partially, but you escape.", reward: 0, penalty: 0, statBonus: { speed: 1, combat: 1, magic: 1, luck: 1 } },
                    { text: "Search for treasure", stat: 'luck', success: "You find an ancient coin worth 40 gold!", fail: "You trigger a trap but escape unharmed.", reward: 40, penalty: 0 },
                    { text: "Leave immediately", stat: null, success: "You wisely avoid any potential danger.", fail: "", reward: 0, penalty: 0 }
                ]
            },
            {
                title: "Forgotten Backpack",
                description: "You find a dusty old backpack tucked away in a small alcove. It seems to have something inside.",
                choices: [
                    { text: "Open it carefully", stat: 'luck', success: "Inside, you find a 'Mystic Compass'!", fail: "It's empty, just cobwebs.", reward: 0, penalty: 0, item: "Mystic Compass" },
                    { text: "Leave it, might be trapped", stat: null, success: "You decide to leave it undisturbed.", fail: "", reward: 0, penalty: 0 }
                ]
            },
            {
                title: "A Lost Creature",
                description: "You come across a small, lost wolf pup whimpering in the bushes. It looks hungry but wary.",
                choices: [
                    {
                        text: "Offer some food and try to befriend it (Luck 7+)",
                        stat: 'luck', // Requires a luck check
                        success: "The pup cautiously approaches and accepts your offering. It seems to trust you! You've gained a companion!",
                        fail: "The pup gets scared and runs away into the undergrowth.",
                        reward: 0, // No gold reward/penalty
                        penalty: 0,
                        action: function(character) { // Custom action for success
                            if (!character.pets) character.pets = [];
                            const petName = "Wolf Pup"; 
                            let variation = null;
                            const rand = Math.random();
                            if (rand < 0.05) { // 5% chance for shiny
                                variation = 'shiny';
                            } else if (rand < 0.10) { // Next 5% chance for ghost (0.05 to 0.0999...)
                                variation = 'ghost';
                            }

                            const newPet = { 
                                id: 'pet_' + Date.now(), // Simple unique ID
                                type: "Wolf", 
                                name: petName,
                                variation: variation // Add variation property
                            };
                            character.pets.push(newPet);

                            let variationText = "";
                            if (newPet.variation === 'shiny') {
                                variationText = "[Shiny] ";
                            } else if (newPet.variation === 'ghost') {
                                variationText = "[Ghost] ";
                            }
                            
                            if (variationText) {
                                return `A wild ${variationText}${newPet.name} has joined you!`;
                            }
                            return `You named your new companion ${newPet.name}.`;
                        }
                    },
                    {
                        text: "Leave it be.",
                        stat: null,
                        success: "You decide to leave the creature to its fate.",
                        fail: "",
                        reward: 0,
                        penalty: 0
                    }
                ]
            },
            // --- WOODCUTTING EVENTS ---
            {
                title: "Productive Chop",
                description: "You find a patch of sturdy trees. A good opportunity to gather some wood.",
                requiredTerrain: ['forest', 'woodland'],
                choices: [
                    { 
                        text: "Gather basic logs (Woodcutting 1+)", 
                        stat: 'woodcutting', 
                        success: "You expertly chop down a tree and gather some useful Oak Logs.", 
                        fail: "You struggle a bit, but manage to get a few usable pieces of Pine Wood.", 
                        reward: 0, 
                        item: "Oak Logs", // Success item
                        failItem: "Pine Wood" // Optional: item on fail
                    },
                    { 
                        text: "Search for rare Forest Blooms (Luck 5+)", 
                        stat: 'luck', 
                        success: "Your keen eye spots a rare Forest Bloom hidden amongst the roots!", 
                        fail: "You find nothing but common leaves.", 
                        reward: 0, 
                        item: "Forest Bloom"
                    }
                ]
            },
            {
                title: "Overgrown Trail",
                description: "An old trail is blocked by thorny bushes. Clearing it might reveal something.",
                requiredTerrain: ['forest', 'woodland', 'swamp'],
                choices: [
                    { 
                        text: "Hack through (Woodcutting 3+)", 
                        stat: 'woodcutting', 
                        success: "You clear the path and find a small bundle of Yew Wood.", 
                        fail: "The thorns are too tough, and you give up.", 
                        reward: 0, 
                        item: "Yew Wood" 
                    },
                     { 
                        text: "Carefully search the edges (Luck 4+)", 
                        stat: 'luck', 
                        success: "Poking around, you find some Nightshade Berries.", 
                        fail: "You only find more thorns.", 
                        reward: 0, 
                        item: "Nightshade Berries" 
                    },
                    { 
                        text: "Leave it.", 
                        stat: null, 
                        success: "You decide it's not worth the effort.", 
                        fail: "", 
                        reward: 0 
                    }
                ]
            },
            // --- MINING EVENTS ---
            {
                title: "Ore Vein",
                description: "You spot a promising glint in a rock face. Could be valuable ore!",
                requiredTerrain: ['mountains', 'cave', 'rocky', 'hills'],
                choices: [
                    { 
                        text: "Mine for Iron Ore (Mining 1+)", 
                        stat: 'mining', 
                        success: "Your efforts pay off! You extract a good amount of Iron Ore.", 
                        fail: "The rock is tougher than it looks. You only get a few ore fragments.", 
                        reward: 0, 
                        item: "Iron Ore",
                        failItem: "Ore Fragments"
                    },
                    { 
                        text: "Look for Shiny Geodes (Luck 7+)", 
                        stat: 'luck', 
                        success: "Tucked away in a crevice, you find a beautiful Shiny Geode!", 
                        fail: "No geodes here, just plain rocks.", 
                        reward: 0, 
                        item: "Shiny Geode" 
                    }
                ]
            },
            {
                title: "Unstable Cavern Entrance",
                description: "A dark cavern entrance beckons. It looks a bit unstable.",
                requiredTerrain: ['mountains', 'cave', 'hills'],
                choices: [
                    { 
                        text: "Carefully explore (Mining 4+)", 
                        stat: 'mining', 
                        success: "You navigate the cavern safely and find a deposit of Coal.", 
                        fail: "A small tremor makes you retreat. Too risky.", 
                        reward: 0, 
                        item: "Coal" 
                    },
                    { 
                        text: "Check for loose gems (Luck 6+)", 
                        stat: 'luck', 
                        success: "Near the entrance, you spot a few Amethyst Shards!", 
                        fail: "It's too dark and unstable to find anything small.", 
                        reward: 0, 
                        item: "Amethyst Shards" 
                    },
                    { 
                        text: "Best not to risk it.", 
                        stat: null, 
                        success: "You steer clear of the dangerous-looking cavern.", 
                        fail: "", 
                        reward: 0 
                    }
                ]
            },
            // --- FISHING EVENTS ---
            {
                title: "Quiet Fishing Spot",
                description: "A serene spot by the water. Looks perfect for fishing.",
                requiredTerrain: ['water', 'coastline', 'river', 'lake'],
                choices: [
                    { 
                        text: "Cast your line (Fishing 1+)", 
                        stat: 'fishing', 
                        success: "A tug on the line! You reel in a plump River Trout.", 
                        fail: "The fish aren't biting today. You catch nothing but seaweed.", 
                        reward: 0, 
                        item: "River Trout",
                        failItem: "Seaweed"
                    },
                    { 
                        text: "Look for Sunken Treasure (Luck 8+)", 
                        stat: 'luck', 
                        success: "You spot something shimmering beneath the water and retrieve an Old Coin!", 
                        fail: "Just murky water and some old boots.", 
                        reward: 0, 
                        item: "Old Coin" 
                    }
                ]
            },
            {
                title: "Mysterious Waters",
                description: "The water here has an unusual color. You wonder what lurks beneath.",
                requiredTerrain: ['water', 'swamp', 'deep_ocean', 'cave_water'],
                choices: [
                    { 
                        text: "Fish with caution (Fishing 5+)", 
                        stat: 'fishing', 
                        success: "Against the odds, you pull out an exotic Moonfin Fish!", 
                        fail: "Something snags your line and breaks it. You lose your bait.", 
                        reward: 0, 
                        item: "Moonfin Fish" 
                    },
                     { 
                        text: "Dredge the bottom (Strength 5+ - Not a real stat yet, using Luck)", // Placeholder for future stat
                        stat: 'luck', // Using luck as a proxy
                        success: "You drag up a barnacle-covered chest containing a Waterlogged Artifact.",
                        fail: "You only manage to stir up mud.",
                        reward: 0,
                        item: "Waterlogged Artifact"
                    },
                    { 
                        text: "Avoid these strange waters.", 
                        stat: null, 
                        success: "You decide not to disturb whatever is in there.", 
                        fail: "", 
                        reward: 0 
                    }
                ]
            }
        ];

        // Toggle panel collapse
        window.togglePanel = function(header) {
            const content = header.nextElementSibling;
            const button = header.querySelector('.collapse-btn');
            const panel = header.parentElement;
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                button.textContent = '−';
                panel.classList.remove('collapsed');
            } else {
                content.classList.add('collapsed');
                button.textContent = '+';
                panel.classList.add('collapsed');
            }
        };

        // Initialize map
        function initMap() {
            gameState.map = L.map('map', {
                zoomControl: false // Remove default zoom controls
            }).setView(gameState.currentPosition, 18);
            
            // Add zoom control to bottom right
            L.control.zoom({
                position: 'bottomleft'
            }).addTo(gameState.map);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(gameState.map);

            // Add character marker
            const characterIcon = L.divIcon({
                className: 'character-marker',
                iconSize: [30, 30]
            });
            
            gameState.characterMarker = L.marker(gameState.currentPosition, { icon: characterIcon })
                .addTo(gameState.map)
                .bindPopup("🧙‍♂️ " + gameState.character.name);

            // Handle map clicks
            gameState.map.on('click', function(e) {
                if (!gameState.isMoving) {
                    setDestination(e.latlng);
                }
            });
        }

        // Set destination and start movement
        function setDestination(latlng) {
            gameState.destination = [latlng.lat, latlng.lng];
            
            // Remove old destination marker
            if (gameState.destinationMarker) {
                gameState.map.removeLayer(gameState.destinationMarker);
            }
            
            // Add new destination marker
            const destIcon = L.divIcon({
                className: 'destination-marker',
                iconSize: [20, 20]
            });
            
            gameState.destinationMarker = L.marker(gameState.destination, { icon: destIcon })
                .addTo(gameState.map)
                .bindPopup("🎯 Destination");

            startMovement();
        }

        // Calculate distance between two points
        function calculateDistance(pos1, pos2) {
            const R = 6371000; // Earth's radius in m
            const dLat = (pos2[0] - pos1[0]) * Math.PI / 180;
            const dLon = (pos2[1] - pos1[1]) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(pos1[0] * Math.PI / 180) * Math.cos(pos2[0] * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Start character movement
        function startMovement() {
            if (gameState.isMoving) return;
            
            gameState.isMoving = true;
            document.getElementById('travelStatus').style.display = 'block';
            
            // Store journey data in gameState for resuming
            gameState.journeyData = {
                startPosition: [...gameState.currentPosition],
                totalDistance: calculateDistance(gameState.currentPosition, gameState.destination),
                distanceTraveled: 0,
                eventCounter: 0
            };
            
            const baseSpeed = gameState.character.speed * 2; // Convert to m per step (original speed was km/step, now m/step)
            
            updateTravelInfo(gameState.journeyData.totalDistance, gameState.journeyData.distanceTraveled);
            
            gameState.moveInterval = setInterval(() => {
                const stepDistance = Math.min(baseSpeed, gameState.journeyData.totalDistance - gameState.journeyData.distanceTraveled);
                
                // Calculate new position based on original journey
                const progress = (gameState.journeyData.distanceTraveled + stepDistance) / gameState.journeyData.totalDistance;
                const newLat = gameState.journeyData.startPosition[0] + (gameState.destination[0] - gameState.journeyData.startPosition[0]) * progress;
                const newLng = gameState.journeyData.startPosition[1] + (gameState.destination[1] - gameState.journeyData.startPosition[1]) * progress;
                
                gameState.characterMarker.setLatLng([newLat, newLng]);
                gameState.journeyData.distanceTraveled += stepDistance;
                
                updateTravelInfo(gameState.journeyData.totalDistance, gameState.journeyData.distanceTraveled);
                
                // Check for events
                gameState.journeyData.eventCounter++;
                if (gameState.journeyData.eventCounter >= Math.max(3, Math.floor(20 / gameState.character.speed)) && Math.random() < 0.4) {
                    gameState.journeyData.eventCounter = 0;
                    pauseMovement();
                    triggerRandomEvent();
                    return;
                }
                
                // Check if destination reached
                if (gameState.journeyData.distanceTraveled >= gameState.journeyData.totalDistance) {
                    completeMovement();
                }
            }, 1000);
        }

        // Update travel information display
        function updateTravelInfo(totalDistance, distanceTraveled) {
            const progress = (distanceTraveled / totalDistance) * 100;
            document.getElementById('travelInfo').textContent = 
                `Distance: ${distanceTraveled.toFixed(0)}/${totalDistance.toFixed(0)} m`;
            document.getElementById('progressFill').style.width = progress + '%';
        }

        // Pause movement (for events)
        function pauseMovement() {
            if (gameState.moveInterval) {
                clearInterval(gameState.moveInterval);
                gameState.moveInterval = null;
            }
        }

        // Resume movement after event
        function resumeMovement() {
            if (gameState.isMoving && !gameState.moveInterval && gameState.destination && gameState.journeyData) {
                const baseSpeed = gameState.character.speed * 2; // Convert to m per step (original speed was km/step, now m/step)
                
                gameState.moveInterval = setInterval(() => {
                    const stepDistance = Math.min(baseSpeed, gameState.journeyData.totalDistance - gameState.journeyData.distanceTraveled);
                    
                    // Calculate new position based on original journey
                    const progress = (gameState.journeyData.distanceTraveled + stepDistance) / gameState.journeyData.totalDistance;
                    const newLat = gameState.journeyData.startPosition[0] + (gameState.destination[0] - gameState.journeyData.startPosition[0]) * progress;
                    const newLng = gameState.journeyData.startPosition[1] + (gameState.destination[1] - gameState.journeyData.startPosition[1]) * progress;
                    
                    gameState.characterMarker.setLatLng([newLat, newLng]);
                    gameState.journeyData.distanceTraveled += stepDistance;
                    
                    updateTravelInfo(gameState.journeyData.totalDistance, gameState.journeyData.distanceTraveled);
                    
                    // Check for events
                    gameState.journeyData.eventCounter++;
                    if (gameState.journeyData.eventCounter >= Math.max(3, Math.floor(20 / gameState.character.speed)) && Math.random() < 0.4) {
                        gameState.journeyData.eventCounter = 0;
                        pauseMovement();
                        triggerRandomEvent();
                        return;
                    }
                    
                    // Check if destination reached
                    if (gameState.journeyData.distanceTraveled >= gameState.journeyData.totalDistance) {
                        completeMovement();
                    }
                }, 1000);
            }
        }

        // Complete movement
        function completeMovement() {
            gameState.isMoving = false;
            pauseMovement();
            
            // Update current position
            gameState.currentPosition = [...gameState.destination];
            gameState.destination = null;
            gameState.journeyData = null; // Clear journey data
            
            // Remove destination marker
            if (gameState.destinationMarker) {
                gameState.map.removeLayer(gameState.destinationMarker);
                gameState.destinationMarker = null;
            }
            
            document.getElementById('travelStatus').style.display = 'none';
            addEventLog("🎯 Reached your destination! Click somewhere new to continue exploring.");
            
            saveCharacterData();
        }

        // Cancel travel
        window.cancelTravel = function() {
            gameState.isMoving = false;
            pauseMovement();
            
            if (gameState.destinationMarker) {
                gameState.map.removeLayer(gameState.destinationMarker);
                gameState.destinationMarker = null;
            }
            
            gameState.destination = null;
            gameState.journeyData = null; // Clear journey data
            document.getElementById('travelStatus').style.display = 'none';
            addEventLog("🛑 Journey cancelled. Ready for a new adventure!");
        };

        // Trigger random event
        function triggerRandomEvent() {
            let currentTerrain = gameState.currentTerrainType || 'plains'; // Default if undefined
            let filteredEvents = eventTemplates.filter(event => {
                return !event.requiredTerrain || event.requiredTerrain.length === 0 || event.requiredTerrain.includes(currentTerrain);
            });

            if (filteredEvents.length === 0) {
                // Fallback: if no terrain-specific events found, use only generic events
                filteredEvents = eventTemplates.filter(event => !event.requiredTerrain || event.requiredTerrain.length === 0);
                if (filteredEvents.length === 0) {
                     console.warn("No suitable events found for terrain:", currentTerrain, "and no generic events available.");
                     // Optionally, trigger a very basic default event here if desired
                     // For now, just return to avoid errors if all events somehow require terrain
                     return; 
                }
            }
            
            if (filteredEvents.length > 0) { // Ensure there's at least one event to show
                const event = filteredEvents[Math.floor(Math.random() * filteredEvents.length)];
                showEventModal(event);
            } else {
                console.warn("No events available to trigger after filtering for terrain:", currentTerrain);
            }
        }

        // Show event modal
        function showEventModal(event) {
            document.getElementById('eventTitle').textContent = event.title;
            document.getElementById('eventDescription').textContent = event.description;
            
            const choicesContainer = document.getElementById('eventChoices');
            choicesContainer.innerHTML = '';
            
            event.choices.forEach((choice, index) => {
                const button = document.createElement('button');
                button.className = 'choice-btn';
                button.textContent = choice.text;
                button.onclick = () => handleEventChoice(event, choice);
                choicesContainer.appendChild(button);
            });
            
            document.getElementById('eventModal').style.display = 'flex';
        }

        // Handle event choice
        function handleEventChoice(event, choice) {
            let result = choice.success;
            let goldChange = choice.reward || 0;
            
            // Check if choice requires a stat check
            let successfulOutcome = true; // Assume success initially
            if (choice.stat) {
                const statValue = gameState.character[choice.stat];
                // Dynamic difficulty: base 5 + random(0-4) + (skill level / 2 for slight scaling)
                // For non-skill stats (luck, combat), this /2 will be small or 0 if level is low.
                // For skills like woodcutting, it allows higher levels to succeed more often.
                const difficulty = 5 + Math.floor(Math.random() * 5) + Math.floor((statValue || 0) / 2); 
                const roll = Math.floor(Math.random() * 20) + 1; // d20 roll
                
                // Lower roll is better for this example, or higher if you prefer (adjust difficulty logic then)
                // Let's stick to: roll + statValue >= difficulty for success.
                // For a more skill-centric check: if statValue itself is low, make it harder.
                // A simple check: if stat is a skill (e.g. woodcutting) and value is 0 or undefined, treat as very hard.
                let currentStatValue = statValue || 0;
                if (['woodcutting', 'mining', 'fishing'].includes(choice.stat) && currentStatValue === 0) {
                    currentStatValue = -5; // Penalize if skill is 0
                }


                if (roll + currentStatValue < difficulty) {
                    successfulOutcome = false;
                    result = choice.fail || "Nothing happens.";
                    goldChange = choice.penalty || 0;
                }
            } else if (choice.goldCost) {
                if (gameState.character.gold < choice.goldCost) {
                    successfulOutcome = false; // Can't afford
                    result = "You don't have enough gold!";
                    goldChange = 0;
                } else {
                    // Gold cost is handled after applying gold changes
                }
            }
            
            // Apply gold changes (penalties or costs)
            // Rewards are typically part of the item or a separate 'reward' field for successful outcomes.
            if (choice.goldCost && successfulOutcome) { // Apply cost only if choice was possible and successful
                 gameState.character.gold -= choice.goldCost;
                 goldChange = 0; // Reset goldChange as it was a cost, not a penalty from failure
            } else if (goldChange !== 0) { // This handles penalties from failed stat checks
                 gameState.character.gold = Math.max(0, gameState.character.gold + goldChange);
            }
             updateCharacterDisplay(); // Update display after gold changes
            
            // Apply stat bonuses (only on success)
            if (choice.statBonus && successfulOutcome) {
                Object.keys(choice.statBonus).forEach(stat => {
                    gameState.character[stat] = (gameState.character[stat] || 0) + choice.statBonus[stat];
                });
                updateCharacterDisplay();
            }

            // Check for item grant
            let itemObtained = null;
            if (successfulOutcome && choice.item) {
                itemObtained = choice.item;
            } else if (!successfulOutcome && choice.failItem) {
                itemObtained = choice.failItem;
            }

            if (itemObtained) {
                if (!gameState.character.inventory) { 
                    gameState.character.inventory = [];
                }
                gameState.character.inventory.push(itemObtained);
                updateInventoryDisplay(); 
                // Append to result message
                if (successfulOutcome) {
                     result += ` You obtained: ${itemObtained}!`;
                } else {
                    // If there's a specific fail message, it's already set. 
                    // If fail message is generic, append item info.
                    if (choice.fail === "Nothing happens." || !choice.fail) {
                         result = `You failed, but found ${itemObtained}.`;
                    } else {
                         result += ` You obtained: ${itemObtained}.`;
                    }
                }
            }
            
            // Handle custom action for successful choices (like acquiring a pet)
            let actionMessage = "";
            if (result === choice.success) { // Check if the outcome was the defined success message for this choice
                if (typeof choice.action === 'function') {
                    const petMessage = choice.action(gameState.character);
                    if (petMessage) {
                        actionMessage = " " + petMessage; // Add a space before appending
                    }
                }
                // The pet should be added, now update pet display if the tab exists
                // This function doesn't exist yet, but we're preparing for it.
                // if (document.getElementById('petsTabContent')) { 
                //    if (typeof updatePetDisplay === 'function') updatePetDisplay();
                // }
            }
            result += actionMessage; // Append action message to the overall result
            
            addEventLog(`⚔️ ${event.title}: ${result}`);
            document.getElementById('eventModal').style.display = 'none';
            
            saveCharacterData();

            // Call updatePetDisplay here after a pet might have been added.
            // This function will be created in the next step.
            if (typeof window.updatePetDisplay === 'function') {
                window.updatePetDisplay();
            }
            
            if (gameState.isMoving) {
                resumeMovement();
            }
        }

        // Add event to log
        function addEventLog(message) {
            const logContainer = document.getElementById('eventLogContent');
            const entry = document.createElement('div');
            entry.className = 'event-entry';
            entry.textContent = message;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            // Keep only last 10 entries
            while (logContainer.children.length > 10) {
                logContainer.removeChild(logContainer.firstChild);
            }
        }

        // Update character display
        function updateCharacterDisplay() {
            document.getElementById('characterName').textContent = gameState.character.name;
            document.getElementById('speedStat').textContent = gameState.character.speed;
            document.getElementById('combatStat').textContent = gameState.character.combat;
            document.getElementById('magicStat').textContent = gameState.character.magic;
            document.getElementById('luckStat').textContent = gameState.character.luck;
            document.getElementById('goldStat').textContent = gameState.character.gold;
            // Update new skill displays
            document.getElementById('woodcuttingStat').textContent = gameState.character.woodcutting;
            document.getElementById('miningStat').textContent = gameState.character.mining;
            document.getElementById('fishingStat').textContent = gameState.character.fishing;
        }

        // Save character data
        async function saveCharacterData() {
            // gameState.currentUser should now be the UID after login/creation
            if (window.auth.currentUser && gameState.character) {
                gameState.character.position = gameState.currentPosition;
                // The username/UID is handled by firebase.saveCharacter internally now
                await window.firebase.saveCharacter(gameState.character);
            } else {
                console.warn("saveCharacterData: No current user or character data to save.");
            }
        }

        // Create new character
        window.createCharacter = async function() {
            const username = document.getElementById('usernameInput').value.trim();
            if (!username) {
                alert('Please enter an adventurer name!');
                return;
            }

            const email = username + "@example.com"; // Insecure, for testing
            const password = "password123"; // Insecure, for testing
            alert("DEVELOPMENT NOTE: Using placeholder email '" + email + "' and password 'password123'. This is not secure and for testing only.");

            try {
                const userCredential = await createUserWithEmailAndPassword(window.auth, email, password);
                gameState.currentUser = userCredential.user.uid; // Set UID
                console.log("User account created with UID:", gameState.currentUser);

                // Proceed with existing character creation logic
                const spawnInputOriginal = document.getElementById('spawnLocationInput').value.trim();
            const spawnInput = spawnInputOriginal.toLowerCase();
            
            let startPosition;
            let spawnMessage = "";
            let determinedTerrain = 'plains'; // Default terrain

            const predefinedLocations = {
                "london": { coords: [51.505, -0.09], terrain: 'urban' },
                "whispering forest": { coords: [51.520, -0.100], terrain: 'forest' },
                "dragon's peak": { coords: [51.480, -0.050], terrain: 'mountains' },
                "serene coastline": { coords: [51.500, -0.150], terrain: 'coastline' }
            };

            const randomSpawn = () => {
                return [
                    parseFloat((Math.random() * (51.55 - 51.45) + 51.45).toFixed(5)),
                    parseFloat((Math.random() * (-0.04 - (-0.14)) + (-0.14)).toFixed(5))
                ];
            };

            if (predefinedLocations[spawnInput]) {
                startPosition = predefinedLocations[spawnInput].coords;
                determinedTerrain = predefinedLocations[spawnInput].terrain;
                spawnMessage = `Spawning you in ${spawnInputOriginal} (${determinedTerrain}).`;
            } else if (spawnInput === "random" || spawnInput === "") {
                startPosition = randomSpawn();
                determinedTerrain = 'plains'; // Default for random
                spawnMessage = "Spawning you at a random location (plains).";
            } else {
                // Try geocoding
                try {
                    const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(spawnInputOriginal)}&limit=1`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data && data.length > 0 && data[0].lat && data[0].lon) {
                            startPosition = [parseFloat(data[0].lat), parseFloat(data[0].lon)];
                            // For geocoded locations, we don't have explicit terrain type yet from Nominatim.
                            // We could try to infer based on keywords in address or default.
                            determinedTerrain = 'plains'; // Default for geocoded for now
                            spawnMessage = `Successfully found coordinates for '${spawnInputOriginal}'. Spawning you there (assumed plains).`;
                        } else {
                            startPosition = randomSpawn();
                            determinedTerrain = 'plains';
                            spawnMessage = `Could not find coordinates for '${spawnInputOriginal}'. Spawning you at a random location (plains) instead. Internet connection is required for address lookup.`;
                        }
                    } else {
                        startPosition = randomSpawn();
                        determinedTerrain = 'plains';
                        spawnMessage = `Error looking up '${spawnInputOriginal}'. Spawning you at a random location (plains) instead. Internet connection may be required.`;
                    }
                } catch (error) {
                    console.error("Geocoding error:", error);
                    startPosition = randomSpawn();
                    determinedTerrain = 'plains';
                    spawnMessage = `Error during address lookup for '${spawnInputOriginal}'. Spawning you at a random location (plains) instead. Please check your internet connection.`;
                }
            }
            
            gameState.currentTerrainType = determinedTerrain; // Set the determined terrain

            gameState.character = {
                name: username,
                speed: 8 + Math.floor(Math.random() * 5),
                combat: 8 + Math.floor(Math.random() * 5),
                magic: 8 + Math.floor(Math.random() * 5),
                luck: 8 + Math.floor(Math.random() * 5),
                gold: 50,
                position: startPosition, // Use the chosen/random position
                inventory: [], 
                pets: [], 
                woodcutting: 1, // New skill
                mining: 1,      // New skill
                fishing: 1      // New skill
            };
            
            gameState.currentPosition = gameState.character.position;
            
            await saveCharacterData(); // This will use the UID from auth.currentUser via firebase.saveCharacter
            addEventLog(spawnMessage);
            startGame();

            } catch (error) {
                console.error("Error creating account:", error);
                alert("Error creating account: " + error.message + "\n(Note: Usernames must be unique. If you've used this name before, try 'Continue Journey' or a different name.)");
            }
        };

        // Load existing character
        window.loadCharacter = async function() {
            const username = document.getElementById('usernameInput').value.trim();
            if (!username) {
                alert('Please enter your character name to continue!');
                return;
            }

            const email = username + "@example.com"; // Insecure, for testing
            const password = "password123"; // Insecure, for testing
            alert("DEVELOPMENT NOTE: Using placeholder email '" + email + "' and password 'password123' to sign in. This is not secure and for testing only.");

            try {
                const userCredential = await signInWithEmailAndPassword(window.auth, email, password);
                gameState.currentUser = userCredential.user.uid; // Set UID
                console.log("User signed in with UID:", gameState.currentUser);

                // Now load character data using the UID (firebase.loadCharacter uses UID internally)
                const characterData = await window.firebase.loadCharacter(); 

                if (characterData) {
                    // Ensure inventory is initialized
                    if (!characterData.inventory) characterData.inventory = [];
                    if (!characterData.pets) characterData.pets = [];
                    else {
                        characterData.pets.forEach(pet => {
                            if (pet.variation === undefined) pet.variation = null;
                        });
                    }
                    if (characterData.woodcutting === undefined) characterData.woodcutting = 1;
                    if (characterData.mining === undefined) characterData.mining = 1;
                    if (characterData.fishing === undefined) characterData.fishing = 1;
                    
                    gameState.character = characterData;
                    gameState.currentPosition = characterData.position || [51.505, -0.09]; // Default if no position saved
                    
                    startGame();
                } else {
                    // This case means user authenticated but no character data found for that UID.
                    alert('Account found, but no character data exists for this adventurer. Try "Begin Adventure" to create a new character.');
                    gameState.currentUser = null; // Clear UID as no character data
                    // Optionally sign out the user if no character data is found after login
                    await signOut(window.auth); 
                    console.log("User signed out as no character data was found.");
                }

            } catch (error) {
                console.error("Error signing in:", error);
                alert("Error signing in: " + error.message + "\n(Note: Ensure you've used this name before, or try 'Begin Adventure' with a new name.)");
            }
        };
        
        window.logoutCharacter = async function() {
            try {
                await signOut(window.auth);
                console.log("User signed out successfully.");
                gameState.currentUser = null;
                gameState.character = null;
                
                // Reset map if it exists
                if (gameState.map) {
                    gameState.map.remove();
                    gameState.map = null;
                }
                // Clear markers
                gameState.characterMarker = null;
                gameState.destinationMarker = null;
                // Clear other game state if necessary, e.g., travel status
                if (gameState.moveInterval) clearInterval(gameState.moveInterval);
                gameState.isMoving = false;
                gameState.destination = null;
                gameState.journeyData = null;
                document.getElementById('travelStatus').style.display = 'none';


                document.getElementById('loginPanel').style.display = 'block';
                document.getElementById('gameContainer').style.display = 'none';
                
                const logContainer = document.getElementById('eventLogContent');
                if (logContainer) logContainer.innerHTML = ''; // Clear previous logs
                addEventLog("🚪 You have been successfully logged out. See you next time, adventurer!");
                // Reset username input field
                const usernameInput = document.getElementById('usernameInput');
                if(usernameInput) usernameInput.value = '';


            } catch (error) {
                console.error("Error signing out:", error);
                alert("Error signing out: " + error.message);
            }
        };

        // Start the game
        function startGame() {
            if (!window.auth.currentUser || !gameState.character) {
                alert("Error: Not properly logged in or character data missing. Please log in again.");
                // Ensure UI is reset to login state
                document.getElementById('loginPanel').style.display = 'block';
                document.getElementById('gameContainer').style.display = 'none';
                if (gameState.map) { // Clean up map if it exists
                    gameState.map.remove();
                    gameState.map = null;
                }
                return;
            }

            document.getElementById('loginPanel').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'flex'; // Or 'block' based on your CSS for gameContainer
            
            updateCharacterDisplay();
            
            // Initialize or update map
            if (!gameState.map) {
                initMap(); // This function should set gameState.map
            } else {
                 // If map exists, ensure character marker is updated or created
                if (gameState.characterMarker) {
                    gameState.characterMarker.setLatLng(gameState.currentPosition).bindPopup("🧙‍♂️ " + gameState.character.name);
                } else { // This might happen if map existed but marker didn't, or if initMap needs to be more robust
                    const characterIcon = L.divIcon({ className: 'character-marker', iconSize: [30, 30] });
                    gameState.characterMarker = L.marker(gameState.currentPosition, { icon: characterIcon })
                        .addTo(gameState.map)
                        .bindPopup("🧙‍♂️ " + gameState.character.name);
                }
                gameState.map.setView(gameState.currentPosition, gameState.map.getZoom() || 18); // Ensure map is centered
            }

            // Set currentTerrainType (this logic seems okay, but ensure predefinedLocations is accessible)
            // Assuming predefinedLocations is defined globally or passed appropriately.
            // For safety, ensure it's defined, or this block might error.
            // const predefinedLocations = { /* ... as defined elsewhere ... */ };
            if (!gameState.currentTerrainType || gameState.currentTerrainType === 'plains') { 
                const pos = gameState.currentPosition;
                let foundKnownLocation = false;
                // Ensure predefinedLocations is available in this scope
                // This might need to be moved or passed if it's not globally available from the other script block
                const predefinedLocations = {
                    "london": { coords: [51.505, -0.09], terrain: 'urban' },
                    "whispering forest": { coords: [51.520, -0.100], terrain: 'forest' },
                    "dragon's peak": { coords: [51.480, -0.050], terrain: 'mountains' },
                    "serene coastline": { coords: [51.500, -0.150], terrain: 'coastline' }
                };
                for (const key in predefinedLocations) {
                    if (predefinedLocations[key].coords[0] === pos[0] && predefinedLocations[key].coords[1] === pos[1]) {
                        gameState.currentTerrainType = predefinedLocations[key].terrain;
                        foundKnownLocation = true;
                        break;
                    }
                }
                if (!foundKnownLocation) {
                    gameState.currentTerrainType = 'plains';
                }
            }
             if (typeof gameState.currentTerrainType === 'undefined') {
                gameState.currentTerrainType = 'plains'; 
            }
            
            addEventLog(`🌟 Welcome, ${gameState.character.name}! Your current terrain is ${gameState.currentTerrainType}. Your adventure begins/continues...`);
            updateInventoryDisplay(); 
            window.openTab('character'); 
            window.updatePetDisplay();
        }

        // Function to update the inventory display
        function updateInventoryDisplay() {
            const inventoryContent = document.getElementById('inventoryContent');
            if (!inventoryContent) { // Add a guard clause in case this is called before the element is in the new tab
                console.warn("updateInventoryDisplay called but inventoryContent not found");
                return;
            }
            inventoryContent.innerHTML = ''; // Clear current display

            if (gameState.character && gameState.character.inventory && gameState.character.inventory.length > 0) {
                gameState.character.inventory.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'inventory-item';
                    // Assuming item is a string for now. If it's an object, use item.name or similar.
                    itemDiv.textContent = item; 
                    inventoryContent.appendChild(itemDiv);
                });
            } else {
                const noItemsDiv = document.createElement('div');
                noItemsDiv.className = 'inventory-item';
                noItemsDiv.textContent = 'No items yet.';
                inventoryContent.appendChild(noItemsDiv);
            }
        }

        // Initialize game on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Game starts with login panel visible

            const tabButtons = document.querySelectorAll('#unifiedUIPanel .tab-button');
            tabButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const tabName = this.getAttribute('data-tab');
                    window.openTab(tabName);
                });
            });
        });

        window.openTab = function(tabBaseName) {
           // Hide all tab content
           const tabContents = document.querySelectorAll('#unifiedUIPanel .tab-content'); // Scope query to unified panel
           tabContents.forEach(content => {
               content.style.display = 'none';
           });

           // Deactivate all tab buttons
           const tabButtons = document.querySelectorAll('#unifiedUIPanel .tab-button'); // Scope query to unified panel
           tabButtons.forEach(button => {
               button.classList.remove('active');
           });

           // Show the selected tab content
           const selectedTabContentId = tabBaseName + "TabContent";
           const selectedTabContent = document.getElementById(selectedTabContentId);
           if (selectedTabContent) {
               selectedTabContent.style.display = 'block';
           }

           // Activate the selected tab button
           const activeButton = document.querySelector(`.tab-button[data-tab='${tabBaseName}']`);
           if (activeButton) {
               activeButton.classList.add('active');
           }
       }

       window.updatePetDisplay = function() {
           const petsContent = document.getElementById('petsTabContent');
           if (!petsContent) return; // Exit if the pets tab content area isn't found

           petsContent.innerHTML = ''; // Clear previous pet list

           if (gameState.character && gameState.character.pets && gameState.character.pets.length > 0) {
               const petList = document.createElement('ul');
               petList.style.listStyleType = 'none'; // Optional: remove bullets
               petList.style.padding = '0';

               gameState.character.pets.forEach(pet => {
                   const petItem = document.createElement('li');
                   petItem.style.padding = '5px 0';
                   petItem.style.borderBottom = '1px solid #444'; // Optional: separator

                   // Display pet icon based on type (simple emojis for now)
                   let petIcon = '❓'; // Default icon
                   if (pet.type.toLowerCase() === 'wolf') {
                       petIcon = '🐺';
                   } else if (pet.type.toLowerCase() === 'bear') {
                       petIcon = '🐻';
                   } else if (pet.type.toLowerCase() === 'goblin') {
                       petIcon = '👺';
                   }

                   let displayName = pet.name;
                   petItem.style.color = ''; // Reset color
                   petItem.style.opacity = ''; // Reset opacity

                   if (pet.variation === 'shiny') {
                       displayName = `[Shiny] ${pet.name}`;
                       petItem.style.color = '#FFD700'; // Gold color for shiny
                   } else if (pet.variation === 'ghost') {
                       displayName = `[Ghost] ${pet.name}`;
                       petItem.style.opacity = '0.7'; // Slight transparency for ghost
                   }
                   
                   petItem.textContent = `${petIcon} ${displayName} (${pet.type})`;
                   petList.appendChild(petItem);
               });
               petsContent.appendChild(petList);
           } else {
               petsContent.innerHTML = '<p>No loyal companions by your side... yet!</p>';
           }
       }
    </script>
</body>
</html>
