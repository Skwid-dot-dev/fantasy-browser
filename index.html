<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy Map Explorer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: #1a1a1a;
            color: #ecf0f1;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        .game-container {
            position: relative;
            height: 100vh;
            width: 100vw;
        }

        #map {
            height: 100vh;
            width: 100vw;
            z-index: 1;
        }

        /* Floating UI Panels */
        .ui-panel {
            position: absolute;
            background: rgba(44, 62, 80, 0.95);
            backdrop-filter: blur(10px);
            border: 2px solid #f39c12;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .ui-panel.collapsed {
            opacity: 0.7;
            transform: scale(0.95);
        }

        .ui-panel:hover {
            opacity: 1;
            transform: scale(1);
        }

        /* Character Panel - Top Left */
        .character-panel {
            top: 20px;
            left: 20px;
            width: 280px;
            max-height: 400px;
            overflow-y: auto;
        }

        /* Travel Status - Bottom Right */
        .travel-status {
            top: auto;
            bottom: 20px;
            right: 20px;
            width: 300px;
            background: rgba(46, 204, 113, 0.95);
            border-color: #2ecc71;
            display: none;
        }

        /* Event Log - Bottom Left */
        .event-log {
            bottom: 20px;
            left: 20px;
            width: 320px;
            max-height: 250px;
            background: rgba(142, 68, 173, 0.95);
            border-color: #9b59b6;
        }

        /* Instructions Panel - Bottom Right */
        .instructions {
            bottom: 20px;
            right: 20px;
            width: 280px;
            background: rgba(52, 152, 219, 0.95);
            border-color: #3498db;
        }

        /* Unified UI Panel Styling */
        .unified-ui-panel {
            position: absolute; /* Or fixed, depending on desired behavior with map scroll */
            top: 10px;
            left: 10px;
            width: 320px; /* Or desired width */
            max-height: calc(100vh - 20px); /* Adjust based on top/bottom margin */
            background: rgba(44, 62, 80, 0.95); /* Similar to existing panels */
            backdrop-filter: blur(10px);
            border: 2px solid #f39c12;
            border-radius: 15px;
            padding: 0; /* Padding will be handled by tab content or header */
            box-shadow: 0 8px 32px rgba(0,0,0,0.6);
            z-index: 1000; /* Ensure it's above the map */
            display: flex; /* Use flex to arrange tab bar and content */
            flex-direction: column;
            overflow: hidden; /* Prevent content from spilling out before scroll is implemented */
        }

        /* Tab Bar Styling */
        .tab-bar {
            display: flex;
            justify-content: space-around; /* Or space-between, or flex-start */
            align-items: center;
            background: rgba(30, 40, 50, 0.8); /* Slightly darker or different from panel bg */
            padding: 5px 0;
            border-bottom: 1px solid #f39c12;
            flex-shrink: 0; /* Prevent tab bar from shrinking */
        }

        /* Tab Button Styling */
        .tab-button {
            background: none;
            border: none;
            color: #ecf0f1;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 1.1em; /* Adjust as needed for emojis later */
            transition: background 0.2s ease, color 0.2s ease;
            border-radius: 5px; /* Optional: for rounded hover effect */
        }

        .tab-button:hover {
            background: rgba(243, 156, 18, 0.2);
            color: #f39c12;
        }

        .tab-button.active { /* Style for the active tab */
            background: rgba(243, 156, 18, 0.3);
            color: #f39c12;
            font-weight: bold;
        }

        /* Tab Content Styling */
        .tab-content {
            display: none; /* Hidden by default, JS will show the active one */
            padding: 15px;
            overflow-y: auto; /* Allow scrolling for content that exceeds panel height */
            flex-grow: 1; /* Allow content to take available space */
        }

        .tab-content > .panel-content {
            margin: 0; 
            padding: 0; 
        }

        /* Optional: Add a transition for a smoother collapse/expand */
        .unified-ui-panel .tab-content {
            transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease, margin 0.3s ease;
        }

        .unified-ui-panel.content-collapsed .tab-content {
            display: none !important; /* Ensure it overrides other display styles */
            max-height: 0;
            padding: 0;
            margin: 0;
            opacity: 0;
        }
        
        #characterTabContent .stat-row { 
            /* Add specific overrides if necessary */
        }
        #inventoryTabContent {
          /* Styles for inventory items might need to be checked */
        }
        #eventLogTabContent .event-entry {
          /* Styles for event entries might need to be checked */
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .ui-panel {
                position: fixed;
                max-width: calc(100vw - 40px);
                font-size: 0.9em;
            }

            .character-panel {
                top: 10px;
                left: 10px;
                right: 10px;
                width: auto;
                max-height: 200px;
            }

            .travel-status {
                top: 10px;
                left: 10px;
                right: 10px;
                width: auto;
            }

            .event-log {
                bottom: 10px;
                left: 10px;
                right: 10px;
                width: auto;
                max-height: 150px;
            }

            .instructions {
                bottom: 170px;
                left: 10px;
                right: 10px;
                width: auto;
            }
        }

        /* Collapsible Panel Headers */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
            user-select: none;
        }

        .panel-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #f39c12;
        }

        .collapse-btn {
            background: none;
            border: none;
            color: #f39c12;
            font-size: 1.2em;
            cursor: pointer;
            padding: 5px;
            border-radius: 3px;
            transition: background 0.2s ease;
        }

        .collapse-btn:hover {
            background: rgba(243, 156, 18, 0.2);
        }

        .panel-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .panel-content.collapsed {
            max-height: 0;
            opacity: 0;
            padding: 0;
            margin: 0;
        }

        .character-panel {
            background: rgba(52, 73, 94, 0.9);
            border: 2px solid #f39c12;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .character-name {
            font-size: 1.3em;
            color: #f39c12;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            padding: 4px 8px;
            background: rgba(0,0,0,0.2);
            border-radius: 5px;
            font-size: 0.9em;
        }

        .stat-label {
            font-weight: bold;
            color: #bdc3c7;
        }

        .stat-value {
            color: #f39c12;
            font-weight: bold;
        }

        .travel-status {
            background: rgba(46, 204, 113, 0.2);
            border: 2px solid #2ecc71;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .travel-status h3 {
            color: #2ecc71;
            margin-bottom: 10px;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2ecc71, #27ae60);
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .event-log {
            background: rgba(142, 68, 173, 0.2);
            border: 2px solid #9b59b6;
            border-radius: 10px;
            padding: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .event-log h3 {
            color: #9b59b6;
            margin-bottom: 10px;
        }

        .event-entry {
            background: rgba(0,0,0,0.3);
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            font-size: 0.9em;
            border-left: 3px solid #9b59b6;
        }

        .event-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .event-content {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            border: 3px solid #f39c12;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center;
        }

        .event-title {
            font-size: 1.6em;
            color: #f39c12;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .event-description {
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 20px;
            color: #ecf0f1;
        }

        .event-choices {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .choice-btn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        /* Specific styling for "Use" button in inventory to be less prominent than event choice buttons */
        #inventoryContent .choice-btn {
            background: linear-gradient(135deg, #566573, #414a52); /* Darker, less vibrant */
            padding: 5px 10px; /* Smaller padding */
            font-size: 0.9em; /* Smaller font */
        }
        #inventoryContent .choice-btn:hover {
            background: linear-gradient(135deg, #414a52, #2c3e50);
        }


        .choice-btn:hover {
            background: linear-gradient(135deg, #c0392b, #a93226);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .login-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #2c3e50, #34495e);
            border: 3px solid #f39c12;
            border-radius: 15px;
            padding: 30px;
            z-index: 10001;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .login-panel h2 {
            color: #f39c12;
            margin-bottom: 20px;
        }

        .login-panel input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 2px solid #34495e;
            border-radius: 5px;
            background: rgba(52, 73, 94, 0.5);
            color: #ecf0f1;
            font-size: 1em;
        }

        .login-panel input:focus {
            outline: none;
            border-color: #f39c12;
        }

        .login-btn {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            margin: 10px 5px;
            transition: all 0.3s ease;
        }

        .login-btn:hover {
            background: linear-gradient(135deg, #e67e22, #d35400);
            transform: translateY(-2px);
        }

        .character-marker {
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, #f39c12, #e67e22);
            border: 3px solid #2c3e50;
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(243, 156, 18, 0.8);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 15px rgba(243, 156, 18, 0.8); }
            50% { box-shadow: 0 0 25px rgba(243, 156, 18, 1); }
            100% { box-shadow: 0 0 15px rgba(243, 156, 18, 0.8); }
        }

        .destination-marker {
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #e74c3c, #c0392b);
            border: 2px solid #fff;
            border-radius: 50%;
            animation: bounce 1s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        .instructions {
            background: rgba(52, 152, 219, 0.2);
            border: 2px solid #3498db;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        .instructions h4 {
            color: #3498db;
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="login-panel" id="loginPanel">
        <h2 id="loginPanelTitle">üó°Ô∏è Enter the Realm üó°Ô∏è</h2>
        <input type="email" id="emailInput" placeholder="Enter your email" style="width: 100%; padding: 10px; margin: 10px 0; border: 2px solid #34495e; border-radius: 5px; background: rgba(52, 73, 94, 0.5); color: #ecf0f1; font-size: 1em;">
        <input type="password" id="passwordInput" placeholder="Password" style="width: 100%; padding: 10px; margin: 10px 0; border: 2px solid #34495e; border-radius: 5px; background: rgba(52, 73, 94, 0.5); color: #ecf0f1; font-size: 1em;">
        
        <div id="registrationFields" style="display: none;">
            <input type="text" id="usernameInput" placeholder="Character Name (for new registration)" maxlength="20" style="width: 100%; padding: 10px; margin: 10px 0; border: 2px solid #34495e; border-radius: 5px; background: rgba(52, 73, 94, 0.5); color: #ecf0f1; font-size: 1em;">
            <input type="password" id="confirmPasswordInput" placeholder="Confirm your password" style="width: 100%; padding: 10px; margin: 10px 0; border: 2px solid #34495e; border-radius: 5px; background: rgba(52, 73, 94, 0.5); color: #ecf0f1; font-size: 1em;">
            <br>
            <label for="spawnLocationInput" id="spawnLocationLabel" style="display: block; margin-top:10px; text-align: left;">Choose Starting Area:</label>
            <input type="text" id="spawnLocationInput" placeholder="e.g., forest, mountains, or a real address like 'Spartanburg SC'" style="width: 100%; padding: 10px; margin: 10px 0; border: 2px solid #34495e; border-radius: 5px; background: rgba(52, 73, 94, 0.5); color: #ecf0f1; font-size: 1em;">
        </div>

        <div id="loginSpecificFields">
            <div style="margin: 10px 0; text-align: left;">
                <input type="checkbox" id="rememberMeCheckbox" style="margin-right: 5px; vertical-align: middle;">
                <label for="rememberMeCheckbox" style="color: #ecf0f1; font-size: 0.9em; vertical-align: middle;">Remember me</label>
            </div>
            <a href="#" id="forgotPasswordLink" style="display: block; margin-top: 10px; color: #f39c12; text-decoration: none;">Forgot Password?</a>
        </div>
        
        <div id="authError" style="color: red; margin-bottom: 10px; margin-top: 10px; min-height: 1.2em;"></div>

        <button class="login-btn" id="loginButton" onclick="loadCharacter()">Login</button>
        <button class="login-btn" id="switchToRegisterButton" onclick="showRegisterForm()">New Adventurer? Register</button>
        
        <button class="login-btn" id="completeRegisterButton" onclick="createCharacter()" style="display: none;">Complete Registration</button>
        <button class="login-btn" id="backToLoginButton" onclick="showLoginForm()" style="display: none;">Back to Login</button>
    </div>

    <div class="game-container" id="gameContainer" style="display: none;">
        <div id="map"></div>

        <div id="unifiedUIPanel" class="ui-panel unified-ui-panel">
            <div class="tab-bar">
                <button class="tab-button" data-tab="character">‚öîÔ∏è</button>
                <button class="tab-button" data-tab="inventory">üéí</button>
                <button class="tab-button" data-tab="pets">üêæ</button> 
                <button class="tab-button" data-tab="eventLog">üìú</button>
                <button class="tab-button" data-tab="instructions">üó∫Ô∏è</button>
                <button class="tab-button" data-tab="distance">üìè</button>
                <button class="tab-button" onclick="window.logoutCharacter()">üö™</button>
            </div>
            <div id="characterTabContent" class="tab-content">
                <div class="character-name" id="characterName">Adventurer</div>
                <div class="stat-row">
                    <span class="stat-label">üèÉ Speed:</span>
                    <span class="stat-value" id="speedStat">10</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">‚öîÔ∏è Combat:</span>
                    <span class="stat-value" id="combatStat">10</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üßô Magic:</span>
                    <span class="stat-value" id="magicStat">10</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üçÄ Luck:</span>
                    <span class="stat-value" id="luckStat">10</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üí™ Strength:</span>
                    <span class="stat-value" id="strengthStat">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üí∞ Gold:</span>
                    <span class="stat-value" id="goldStat">50</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">‚ù§Ô∏è Health:</span>
                    <span class="stat-value"><span id="healthStat">100</span> / <span id="maxHealthStat">100</span></span>
                </div>
                <hr style="border-top: 1px solid #f39c12; margin: 10px 0;"> 
                <div class="stat-row">
                    <span class="stat-label">üå≤ Woodcutting:</span>
                    <span class="stat-value" id="woodcuttingStat">1</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">‚õèÔ∏è Mining:</span>
                    <span class="stat-value" id="miningStat">1</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">üé£ Fishing:</span>
                    <span class="stat-value" id="fishingStat">1</span>
                </div>
                <hr style="border-top: 1px solid #f39c12; margin: 10px 0;">
                <div class="stat-row" style="flex-direction: column; align-items: flex-start;">
                    <span class="stat-label">Active Effects:</span>
                    <div id="activeEffectsList" style="font-size: 0.85em; padding-left: 10px; margin-top: 5px;">
                        <div>None</div> 
                    </div>
                </div>
            </div>
            <div id="inventoryTabContent" class="tab-content">
                <div class="panel-content" id="inventoryContent">
                <div class="inventory-item">No items yet.</div>
            </div>
            </div>
            <div id="eventLogTabContent" class="tab-content">
                <div class="panel-content" id="eventLogContent">
                <div class="event-entry">Welcome to the mystical realm! Click on the map to begin your journey.</div>
            </div>
            </div>
            <div id="instructionsTabContent" class="tab-content">
                <p>Click anywhere on the map to set your destination. Your character will travel there, encountering various events along the way!</p>
            </div>
            <div id="distanceTabContent" class="tab-content">
                <div id="currentJourneyDistanceDisplay">Current Journey: 0 m / 0 m</div>
                <div id="lifetimeDistanceDisplay">Lifetime Distance: 0 m</div>
            </div>
            <div id="petsTabContent" class="tab-content">
                <!-- Acquired pets will be listed here by JavaScript -->
            </div>
        </div>
        
        <!-- Character Panel - Top Left -->
        <div class="ui-panel character-panel" style="display: none;">
            <div class="panel-header" onclick="togglePanel(this)">
                <div class="panel-title">‚öîÔ∏è Character</div>
                <button class="collapse-btn">‚àí</button>
            </div>
            <div class="panel-content">
                
            </div>
        </div>

        <!-- Inventory Panel - e.g., Below Character Panel -->
        <div class="ui-panel inventory-panel" style="top: 440px; left: 20px; width: 280px; max-height: 200px; display: none;">
            <div class="panel-header" onclick="togglePanel(this)">
                <div class="panel-title">üéí Inventory</div>
                <button class="collapse-btn">‚àí</button>
            </div>
            <div class="panel-content" id="inventoryContent_original">
                
            </div>
        </div>

        <!-- Travel Status - Top Right -->
        <div class="ui-panel travel-status" id="travelStatus" style="display: none;">
            <div class="panel-header" onclick="togglePanel(this)">
                <div class="panel-title">üö∂ Journey</div>
                <button class="collapse-btn">‚àí</button>
            </div>
            <div class="panel-content">
                <div id="travelInfo">Ready to adventure!</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <button class="choice-btn" onclick="cancelTravel()" style="margin-top: 8px; padding: 8px 16px; font-size: 0.9em;">Cancel Journey</button>
            </div>
        </div>

        <!-- Instructions - Bottom Right -->
        <div class="ui-panel instructions" style="display: none;">
            <div class="panel-header" onclick="togglePanel(this)">
                <div class="panel-title">üó∫Ô∏è Controls</div>
                <button class="collapse-btn">‚àí</button>
            </div>
            <div class="panel-content">
                
            </div>
        </div>

        <!-- Event Log - Bottom Left -->
        <div class="ui-panel event-log" style="display: none;">
            <div class="panel-header" onclick="togglePanel(this)">
                <div class="panel-title">üìú Adventure Log</div>
                <button class="collapse-btn">‚àí</button>
            </div>
            <div class="panel-content" id="eventLogContent_original">
                
            </div>
        </div>
    </div>

    <div class="event-modal" id="eventModal">
        <div class="event-content">
            <div class="event-title" id="eventTitle">Random Encounter</div>
            <div class="event-description" id="eventDescription">Something interesting happens...</div>
            <div class="event-choices" id="eventChoices"></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script type="module">
      // Import the functions you need from the SDKs you need
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-app.js";
      import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-analytics.js";
      import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, sendEmailVerification, sendPasswordResetEmail, setPersistence, browserLocalPersistence, browserSessionPersistence } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-auth.js";
      import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-firestore.js";

      // Your web app's Firebase configuration
      const firebaseConfig = {
        apiKey: "AIzaSyDFuK9Tf89hwAG7L_is8NY00kn-Y44E8Qg",
        authDomain: "fantasy-browser-5de23.firebaseapp.com",
        projectId: "fantasy-browser-5de23",
        storageBucket: "fantasy-browser-5de23.firebasestorage.app",
        messagingSenderId: "976083957249",
        appId: "1:976083957249:web:720073a57c62074df0b200",
        measurementId: "G-SYQLZKXBRG"
      };

      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const analytics = getAnalytics(app);
      const auth = getAuth(app);
      const db = getFirestore(app);

      window.firebaseAuthFunctions = {
          createUserWithEmailAndPassword,
          signInWithEmailAndPassword,
          signOut,
          sendEmailVerification,
          sendPasswordResetEmail,
          setPersistence, 
          Auth: { 
              Persistence: {
                  LOCAL: browserLocalPersistence,
                  SESSION: browserSessionPersistence
              }
          }
      };

      window.auth = auth;
      window.db = db;
      window.firebase = {
          saveCharacter: async (characterData) => { 
              if (!window.auth.currentUser) {
                  console.error("User not logged in. Cannot save character.");
                  alert("Error: You are not logged in. Cannot save character.");
                  return Promise.reject("User not logged in");
              }
              const uid = window.auth.currentUser.uid;
              const userDocRef = doc(db, "characters", uid); 
              try {
                  console.log('Firebase: Attempting to save character:', characterData.name, 'Health:', characterData.health, 'Max Health:', characterData.maxHealth);
                  await setDoc(userDocRef, characterData);
                  console.log("Character saved for UID:", uid);
                  return true;
              } catch (error) {
                  console.error("Error saving character for UID:", uid, error);
                  alert("Error saving character data: " + error.message);
                  return Promise.reject(error);
              }
          },
          loadCharacter: async () => { 
              if (!window.auth.currentUser) {
                  console.error("User not logged in. Cannot load character.");
                  return Promise.resolve(null); 
              }
              const uid = window.auth.currentUser.uid;
              const userDocRef = doc(db, "characters", uid); 
              try {
                  const docSnap = await getDoc(userDocRef);
                  if (docSnap.exists()) {
                      console.log("Character data loaded for UID:", uid);
                      return docSnap.data();
                  } else {
                      console.log("No character document found for UID:", uid);
                      return null;
                  }
              } catch (error) {
                  console.error("Error loading character for UID:", uid, error);
                  alert("Error loading character data: " + error.message);
                  return Promise.resolve(null); 
              }
          },
          logEvent: async (event) => { 
            if (!window.auth.currentUser) {
                console.warn("Event log attempted without logged in user.");
                return;
            }
            const uid = window.auth.currentUser.uid;
            console.log("Event logged for UID (locally, not to Firestore yet):", uid, event);
          }
      };

    </script>
    <script type="module">
        // Game State
        const petImageMapping = {
            'wolf': 'images/wolf.png',
            'bear': 'images/brown_bear.png', 
            'goblin': 'images/goblin.png',   
            'gorilla': 'images/gorilla.png',
            'gryphon': 'images/gryphon.png',
            'minotaur': 'images/minotaur.png'
        };

        // Pet Item Definitions (for reference)
        /*
        const PET_SWORD_TEMPLATE = {
            id: '', // Will be dynamically generated when an instance is created
            name: "Pet Training Sword",
            type: "pet_equipment_weapon", // Type to identify it as pet weapon
            description: "A small, sturdy sword suitable for a pet. Grants +3 Combat to the pet.",
            effects: { combat: 3 }, // Stat bonuses for the pet
            usable: false, // Not usable by the player directly from inventory
            equipableToPet: true, // Custom flag to identify it for pet equipping logic
            quantity: 1
        };

        const PET_BOOTS_TEMPLATE = {
            id: '', // Will be dynamically generated
            name: "Sturdy Pet Boots",
            type: "pet_equipment_armor", // Type to identify it as pet armor/accessory
            description: "Durable little boots for a pet. Grants +2 Speed to the pet.",
            effects: { speed: 2 }, // Stat bonuses for the pet
            usable: false, // Not usable by the player
            equipableToPet: true, // Custom flag
            quantity: 1
        };
        */

        let gameState = {
            currentUser: null,
            character: null,
            map: null,
            currentPosition: [51.505, -0.09], 
            destination: null,
            isMoving: false,
            moveInterval: null,
            characterMarker: null,
            destinationMarker: null,
            currentTerrainType: 'plains' 
        };

        // Event Templates
        const eventTemplates = [
            {
                title: "Bandit Ambush!",
                description: "A group of bandits blocks your path, demanding your gold!",
                choices: [
                    { text: "Fight them! (Combat)", stat: 'combat', success: "You defeat the bandits and find 20 gold!", fail: "You barely escape, losing 10 gold.", reward: 20, penalty: -10 },
                    { text: "Try to sneak past (Luck)", stat: 'luck', success: "You slip by unnoticed!", fail: "They spot you and you lose 5 gold in the scuffle.", reward: 0, penalty: -5 },
                    { text: "Pay them off", stat: null, success: "They let you pass for 15 gold.", fail: "", reward: 0, penalty: -15 }
                ]
            },
            {
                title: "Mystical Shrine",
                description: "You discover an ancient shrine glowing with magical energy.",
                choices: [
                    { text: "Touch the shrine (Magic)", stat: 'magic', success: "The shrine blesses you! +2 Magic permanently!", fail: "The magic backfires, draining your energy.", reward: 0, penalty: 0, statBonus: { magic: 2 } },
                    { text: "Search around it (Luck)", stat: 'luck', success: "You find a hidden cache with 30 gold!", fail: "You find nothing of value.", reward: 30, penalty: 0 },
                    { text: "Leave it alone", stat: null, success: "You continue your journey safely.", fail: "", reward: 0, penalty: 0 }
                ]
            },
            {
                title: "Traveling Merchant",
                description: "A friendly merchant offers to trade with you.",
                choices: [
                    { text: "Buy speed boots (30 gold)", stat: null, success: "Your speed increases by 3!", fail: "", reward: 0, penalty: -30, statBonus: { speed: 3 }, goldCost: 30 },
                    { text: "Buy lucky charm (25 gold)", stat: null, success: "Your luck increases by 2!", fail: "", reward: 0, penalty: -25, statBonus: { luck: 2 }, goldCost: 25 },
                    { text: "Just chat", stat: null, success: "The merchant shares wisdom about the road ahead.", fail: "", reward: 0, penalty: 0 }
                ]
            },
            {
                title: "Wild Storm",
                description: "Dark clouds gather and a fierce storm begins!",
                choices: [
                    { text: "Push through (Speed)", stat: 'speed', success: "You outrun the storm!", fail: "You get caught in the rain and feel sluggish.", reward: 0, penalty: 0 },
                    { text: "Seek shelter (Luck)", stat: 'luck', success: "You find a cozy inn and rest well!", fail: "You huddle under a tree, getting soaked.", reward: 0, penalty: 0 },
                    { text: "Use magic protection", stat: 'magic', success: "Your magical barrier keeps you dry!", fail: "Your spell fails and you're drenched.", reward: 0, penalty: 0 }
                ]
            },
            {
                title: "Ancient Ruins",
                description: "You stumble upon mysterious ancient ruins with strange markings.",
                choices: [
                    { text: "Investigate carefully", stat: 'magic', success: "You decipher ancient magic and gain power! +1 to all stats!", fail: "The ruins collapse partially, but you escape.", reward: 0, penalty: 0, statBonus: { speed: 1, combat: 1, magic: 1, luck: 1 } },
                    { text: "Search for treasure", stat: 'luck', success: "You find an ancient coin worth 40 gold!", fail: "You trigger a trap but escape unharmed.", reward: 40, penalty: 0 },
                    { text: "Leave immediately", stat: null, success: "You wisely avoid any potential danger.", fail: "", reward: 0, penalty: 0 }
                ]
            },
            {
                title: "Forgotten Backpack",
                description: "You find a dusty old backpack tucked away in a small alcove. It seems to have something inside.",
                choices: [
                    { 
                        text: "Open it carefully", 
                        stat: 'luck', 
                        success: "Inside, you find something useful!", 
                        fail: "It's empty, just cobwebs.", 
                        reward: 0, 
                        penalty: 0, 
                        item: { 
                            name: "Mystic Compass", 
                            type: "tool", 
                            description: "A compass that hums with a faint energy. Might lead to interesting places.", 
                            effects: {}, 
                            usable: false, 
                            quantity: 1 
                        } 
                    },
                    { text: "Leave it, might be trapped", stat: null, success: "You decide to leave it undisturbed.", fail: "", reward: 0, penalty: 0 }
                ]
            },
            {
                title: "Old Medic's Satchel",
                description: "You find an old, weathered satchel. It might contain some medical supplies.",
                choices: [
                    {
                        text: "Search the satchel (Luck 5+)",
                        stat: 'luck',
                        success: "You found a Health Potion!",
                        fail: "The satchel is empty or its contents are ruined.",
                        reward: 0,
                        penalty: 0,
                        item: { 
                            name: "Health Potion", type: "potion", description: "Restores 25 health.",
                            effects: { health: 25 }, usable: true, quantity: 1
                        }
                    },
                    { text: "Leave it.", stat: null, success: "You leave the satchel untouched.", fail: "", reward: 0, penalty: 0 }
                ]
            },
            {
                title: "A Lost Creature",
                description: "You come across a wild creature. It looks wary.",
                choices: [
                    {
                        text: "Offer some food and try to befriend it (Luck 7+)",
                        stat: 'luck', 
                        success: "The creature cautiously approaches and accepts your offering. It seems to trust you!", 
                        fail: "The creature gets scared and runs away into the undergrowth.", 
                        reward: 0,
                        penalty: 0,
                        action: function(character) { 
                            if (!character.pets) character.pets = [];

                            const availablePetTypes = ['Wolf', 'Bear', 'Goblin'];
                            const randomType = availablePetTypes[Math.floor(Math.random() * availablePetTypes.length)];
                            let petName = "";
                            let successMessagePrefix = "A wild";

                            switch (randomType) {
                                case 'Wolf':
                                    petName = "Wild Wolf";
                                    break;
                                case 'Bear':
                                    petName = "Young Bear";
                                    break;
                                case 'Goblin':
                                    petName = "Mischievous Goblin";
                                    break;
                                default: 
                                    petName = "Mysterious Creature";
                                    break;
                            }

                            let variation = null;
                            const rand = Math.random();
                            if (rand < 0.05) { 
                                variation = 'shiny';
                            } else if (rand < 0.10) { 
                                variation = 'ghost';
                            }

                            const newPet = {
                                id: 'pet_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                                type: randomType,
                                name: petName,
                                variation: variation,
                                stats: { luck: 0, strength: 0, speed: 0 },
                                equippedItem: null 
                            };

                            const statKeys = ["luck", "strength", "speed"];
                            for (let i = 0; i < 2; i++) {
                                const randomStatKey = statKeys[Math.floor(Math.random() * statKeys.length)];
                                newPet.stats[randomStatKey]++;
                            }

                            character.pets.push(newPet);

                            let variationText = "";
                            if (newPet.variation === 'shiny') {
                                variationText = "[Shiny] ";
                            } else if (newPet.variation === 'ghost') {
                                variationText = "[Ghost] ";
                            }
                            
                            return `${successMessagePrefix} ${variationText}${newPet.name} (${newPet.type}) has joined you!`;
                        }
                    },
                    {
                        text: "Leave it be.",
                        stat: null,
                        success: "You decide to leave the creature to its fate.",
                        fail: "",
                        reward: 0,
                        penalty: 0
                    }
                ]
            },
            {
                title: "Productive Chop",
                description: "You find a patch of sturdy trees. A good opportunity to gather some wood.",
                requiredTerrain: ['forest', 'woodland'],
                choices: [
                    { 
                        text: "Gather basic logs (Woodcutting 1+)", 
                        stat: 'woodcutting', 
                        success: "You expertly chop down a tree and gather some useful Oak Logs.", 
                        fail: "You struggle a bit, but manage to get a few usable pieces of Pine Wood.", 
                        reward: 0, 
                        item: {name: "Oak Logs", type: "material", description: "Sturdy logs.", quantity: 1},
                        failItem: {name: "Pine Wood", type: "material", description: "Common wood.", quantity: 1} 
                    },
                    { 
                        text: "Search for rare Forest Blooms (Luck 5+)", 
                        stat: 'luck', 
                        success: "Your keen eye spots a rare Forest Bloom hidden amongst the roots!", 
                        fail: "You find nothing but common leaves.", 
                        reward: 0, 
                        item: {name: "Forest Bloom", type: "component", description: "A vibrant, magical bloom.", quantity: 1}
                    }
                ]
            },
            {
                title: "Overgrown Trail",
                description: "An old trail is blocked by thorny bushes. Clearing it might reveal something.",
                requiredTerrain: ['forest', 'woodland', 'swamp'],
                choices: [
                    { 
                        text: "Hack through (Woodcutting 3+)", 
                        stat: 'woodcutting', 
                        success: "You clear the path and find a small bundle of Yew Wood.", 
                        fail: "The thorns are too tough, and you give up.", 
                        reward: 0, 
                        item: {name: "Yew Wood", type: "material", description: "Flexible, strong wood.", quantity: 1} 
                    },
                     { 
                        text: "Carefully search the edges (Luck 4+)", 
                        stat: 'luck', 
                        success: "Poking around, you find some Nightshade Berries.", 
                        fail: "You only find more thorns.", 
                        reward: 0, 
                        item: {name: "Nightshade Berries", type: "component", description: "Poisonous berries.", quantity: 1} 
                    },
                    { 
                        text: "Leave it.", 
                        stat: null, 
                        success: "You decide it's not worth the effort.", 
                        fail: "", 
                        reward: 0 
                    }
                ]
            },
            {
                title: "Ore Vein",
                description: "You spot a promising glint in a rock face. Could be valuable ore!",
                requiredTerrain: ['mountains', 'cave', 'rocky', 'hills'],
                choices: [
                    { 
                        text: "Mine for Iron Ore (Mining 1+)", 
                        stat: 'mining', 
                        success: "Your efforts pay off! You extract a good amount of Iron Ore.", 
                        fail: "The rock is tougher than it looks. You only get a few ore fragments.", 
                        reward: 0, 
                        item: {name: "Iron Ore", type: "material", description: "A lump of iron.", quantity: 1},
                        failItem: {name: "Ore Fragments", type: "material", description: "Small pieces of ore.", quantity: 1}
                    },
                    { 
                        text: "Look for Shiny Geodes (Luck 7+)", 
                        stat: 'luck', 
                        success: "Tucked away in a crevice, you find a beautiful Shiny Geode!", 
                        fail: "No geodes here, just plain rocks.", 
                        reward: 0, 
                        item: {name: "Shiny Geode", type: "valuable", description: "A geode that glitters.", quantity: 1} 
                    }
                ]
            },
            {
                title: "Unstable Cavern Entrance",
                description: "A dark cavern entrance beckons. It looks a bit unstable.",
                requiredTerrain: ['mountains', 'cave', 'hills'],
                choices: [
                    { 
                        text: "Carefully explore (Mining 4+)", 
                        stat: 'mining', 
                        success: "You navigate the cavern safely and find a deposit of Coal.", 
                        fail: "A small tremor makes you retreat. Too risky.", 
                        reward: 0, 
                        item: {name: "Coal", type: "material", description: "A lump of coal.", quantity: 1} 
                    },
                    { 
                        text: "Check for loose gems (Luck 6+)", 
                        stat: 'luck', 
                        success: "Near the entrance, you spot a few Amethyst Shards!", 
                        fail: "It's too dark and unstable to find anything small.", 
                        reward: 0, 
                        item: {name: "Amethyst Shards", type: "valuable", description: "Shards of amethyst.", quantity: 1} 
                    },
                    { 
                        text: "Best not to risk it.", 
                        stat: null, 
                        success: "You steer clear of the dangerous-looking cavern.", 
                        fail: "", 
                        reward: 0 
                    }
                ]
            },
            {
                title: "Quiet Fishing Spot",
                description: "A serene spot by the water. Looks perfect for fishing.",
                requiredTerrain: ['water', 'coastline', 'river', 'lake'],
                choices: [
                    { 
                        text: "Cast your line (Fishing 1+)", 
                        stat: 'fishing', 
                        success: "A tug on the line! You reel in a plump River Trout.", 
                        fail: "The fish aren't biting today. You catch nothing but seaweed.", 
                        reward: 0, 
                        item: {name: "River Trout", type: "food", description: "A freshwater fish.", quantity: 1},
                        failItem: {name: "Seaweed", type: "material", description: "Slimy seaweed.", quantity: 1}
                    },
                    { 
                        text: "Look for Sunken Treasure (Luck 8+)", 
                        stat: 'luck', 
                        success: "You spot something shimmering beneath the water and retrieve an Old Coin!", 
                        fail: "Just murky water and some old boots.", 
                        reward: 0, 
                        item: {name: "Old Coin", type: "valuable", description: "An ancient coin.", quantity: 1} 
                    }
                ]
            },
            {
                title: "Mysterious Waters",
                description: "The water here has an unusual color. You wonder what lurks beneath.",
                requiredTerrain: ['water', 'swamp', 'deep_ocean', 'cave_water'],
                choices: [
                    { 
                        text: "Fish with caution (Fishing 5+)", 
                        stat: 'fishing', 
                        success: "Against the odds, you pull out an exotic Moonfin Fish!", 
                        fail: "Something snags your line and breaks it. You lose your bait.", 
                        reward: 0, 
                        item: {name: "Moonfin Fish", type: "food", description: "A rare, glowing fish.", quantity: 1} 
                    },
                     { 
                        text: "Dredge the bottom (Strength 5+ - Not a real stat yet, using Luck)", 
                        stat: 'luck', 
                        success: "You drag up a barnacle-covered chest containing a Waterlogged Artifact.",
                        fail: "You only manage to stir up mud.",
                        reward: 0,
                        item: {name: "Waterlogged Artifact", type: "quest_item", description: "A strange artifact from the depths.", quantity: 1}
                    },
                    { 
                        text: "Avoid these strange waters.", 
                        stat: null, 
                        success: "You decide not to disturb whatever is in there.", 
                        fail: "", 
                        reward: 0 
                    }
                ]
            },
            {
                title: "Spiky Trap!",
                description: "You accidentally step on a hidden spiky trap.",
                choices: [
                    {
                        text: "Ouch!",
                        stat: null, 
                        success: "The spikes retract. That really hurt.", 
                        fail: "",
                        reward: 0, 
                        penalty: 0,
                        action: function(character) {
                            window.damagePlayer(10); 
                            return "Lost 10 health."; 
                        }
                    }
                ]
            },
            {
                title: "Healing Fountain",
                description: "You discover a small fountain bubbling with clear, glowing water.",
                choices: [
                    {
                        text: "Drink from it (Heal 15)",
                        stat: null,
                        success: "The water is refreshing and invigorating!",
                        fail: "",
                        reward: 0,
                        penalty: 0,
                        action: function(character) {
                            window.healPlayer(15); 
                            return "Gained 15 health."; 
                        }
                    }
                ]
            },
            {
                title: "Mysterious Pet Treat",
                description: "You find a strange, shimmering treat on the ground. It looks like something a pet might enjoy.",
                choices: [
                    {
                        text: "Give it to your active pet.",
                        stat: null, 
                        success: "Your pet seems to enjoy the treat!", 
                        fail: "The treat had no effect, or your pet refused it.",
                        action: function(character) {
                            if (!character.activePetId || !character.pets || character.pets.length === 0) {
                                return "You don't have an active pet to give the treat to.";
                            }
                            const activePet = character.pets.find(p => p.id === character.activePetId);
                            if (!activePet) {
                                return "Could not find your active pet.";
                            }

                            const possibleStatsToBoost = ['luck', 'strength', 'speed'];
                            const statToBoost = possibleStatsToBoost[Math.floor(Math.random() * possibleStatsToBoost.length)];
                            
                            activePet.stats[statToBoost] = (activePet.stats[statToBoost] || 0) + 1;
                            
                            window.updatePetDisplay(); 
                            window.applyCharacterStatModifiers();

                            return `Your ${activePet.name}'s ${statToBoost} increased by 1!`;
                        }
                    },
                    {
                        text: "Leave it.",
                        stat: null,
                        success: "You decide to leave the mysterious treat alone.",
                        fail: "",
                        reward: 0,
                        penalty: 0
                    }
                ]
            },
            {
                title: "Weakening Sickness",
                description: "You feel a sudden chill and a wave of weakness washes over you after passing through a dark bog.",
                choices: [
                    {
                        text: "Endure it.",
                        stat: null,
                        success: "You feel weakened, but decide to push through.", 
                        action: function(character) {
                            if (!character.activeEffects) character.activeEffects = [];
                            
                            const isAlreadySick = character.activeEffects.some(effect => effect.description === "Weakening Sickness");
                            if (isAlreadySick) {
                                return "You are already feeling unwell; thankfully it doesn't seem to get worse.";
                            }

                            character.activeEffects.push({
                                id: 'eff_sickness_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                                stat: 'strength', 
                                amount: -2,       
                                duration: 20,     
                                description: "Weakening Sickness"
                            });
                            window.applyCharacterStatModifiers(); 
                            return "A sickness saps some of your strength (-2 Strength for 20 steps).";
                        }
                    }
                ]
            },
            {
                title: "Scavenger's Find",
                description: "You spot a discarded pile of supplies. Might be something useful there.",
                choices: [
                    {
                        text: "Rummage through the pile (Luck 5+).",
                        stat: 'luck', 
                        success: "You managed to find something useful!", 
                        fail: "The pile contains nothing but junk.",
                        action: function(character) { 
                            const possibleItems = [
                                { name: "Health Potion", type: "potion", description: "Restores 25 health.", effects: { health: 25 }, usable: true, quantity: 1 },
                                { name: "Bandages", type: "consumable", description: "Restores 10 health.", effects: { health: 10 }, usable: true, quantity: 1 },
                                { name: "Mystic Compass", type: "tool", description: "A compass that hums with a faint energy.", effects: {}, usable: false, quantity: 1 }
                            ];
                            const foundItemTemplate = possibleItems[Math.floor(Math.random() * possibleItems.length)];
                            
                            const newItem = {
                                ...foundItemTemplate,
                                id: 'item_scav_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9)
                            };

                            if (!character.inventory) character.inventory = [];
                            character.inventory.push(newItem);
                            updateInventoryDisplay(); 
                            return `You found a ${newItem.name}!`;
                        }
                    },
                    {
                        text: "Leave it.",
                        stat: null,
                        success: "You decide not to risk it."
                    }
                ]
            },
            {
                title: "Armorer's Lost Tools",
                description: "You stumble upon a satchel containing fine tools, clearly belonging to a skilled armorer. There's a note with a local address.",
                choices: [
                    {
                        text: "Return the tools to the armorer.",
                        stat: 'luck', 
                        success: "The grateful armorer thanks you profusely and offers you a reward for your honesty. You receive a Pet Sword!",
                        fail: "You couldn't find the armorer. The address seems to be old and the shop is long gone.",
                        item: {
                            id: '', // Will be set in handleEventChoice if not set here, but good practice to define
                            name: "Armorer's Pet Sword",
                            type: "pet_equipment_weapon",
                            description: "A finely crafted small sword, a gift from a grateful armorer. +3 Combat for your pet.",
                            effects: { combat: 3 },
                            usable: false,
                            equipableToPet: true,
                            quantity: 1
                        }
                    },
                    {
                        text: "Keep the tools. They look valuable.",
                        stat: null,
                        success: "You keep the tools. They might fetch a good price, or perhaps you'll find a use for them. (You gain 25 gold).",
                        reward: 25,
                        penalty: 0
                    }
                ]
            },
            {
                title: "Fleetfoot Courier's Dilemma",
                description: "A panicked courier flags you down. 'My pack burst open! I think I lost a small, specially ordered pair of pet boots! Can you help me search?'",
                choices: [
                    {
                        text: "Help search for the boots (Luck 6+).",
                        stat: 'luck',
                        success: "After a thorough search, you spot the tiny boots near a creek! The courier is overjoyed and lets you keep them as thanks.",
                        fail: "Despite your best efforts, the boots are nowhere to be found. The courier thanks you for trying.",
                        item: {
                            id: '', // Will be set in handleEventChoice
                            name: "Courier's Pet Boots",
                            type: "pet_equipment_armor",
                            description: "Durable little boots, found for a grateful courier. +2 Speed for your pet.",
                            effects: { speed: 2 },
                            usable: false,
                            equipableToPet: true,
                            quantity: 1
                        }
                    },
                    {
                        text: "Sorry, I'm too busy to help.",
                        stat: null,
                        success: "You continue on your way, leaving the flustered courier to their search.",
                        reward: 0,
                        penalty: 0
                    }
                ]
            }
        ];

        // Toggle panel collapse
        window.togglePanel = function(header) {
            const content = header.nextElementSibling;
            const button = header.querySelector('.collapse-btn');
            const panel = header.parentElement;
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                button.textContent = '‚àí';
                panel.classList.remove('collapsed');
            } else {
                content.classList.add('collapsed');
                button.textContent = '+';
                panel.classList.add('collapsed');
            }
        };

        // Initialize map
        function initMap() {
            gameState.map = L.map('map', {
                zoomControl: false 
            }).setView(gameState.currentPosition, 18);
            
            L.control.zoom({
                position: 'bottomleft'
            }).addTo(gameState.map);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(gameState.map);

            const characterIcon = L.divIcon({
                className: 'character-marker',
                iconSize: [30, 30]
            });
            
            gameState.characterMarker = L.marker(gameState.currentPosition, { icon: characterIcon })
                .addTo(gameState.map)
                .bindPopup("üßô‚Äç‚ôÇÔ∏è " + gameState.character.name);

            gameState.map.on('click', function(e) {
                if (!gameState.isMoving) {
                    setDestination(e.latlng);
                }
            });
        }

        // Set destination and start movement
        function setDestination(latlng) {
            gameState.destination = [latlng.lat, latlng.lng];
            
            if (gameState.destinationMarker) {
                gameState.map.removeLayer(gameState.destinationMarker);
            }
            
            const destIcon = L.divIcon({
                className: 'destination-marker',
                iconSize: [20, 20]
            });
            
            gameState.destinationMarker = L.marker(gameState.destination, { icon: destIcon })
                .addTo(gameState.map)
                .bindPopup("üéØ Destination");

            startMovement();
        }

        // Calculate distance between two points
        function calculateDistance(pos1, pos2) {
            const R = 6371000; 
            const dLat = (pos2[0] - pos1[0]) * Math.PI / 180;
            const dLon = (pos2[1] - pos1[1]) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(pos1[0] * Math.PI / 180) * Math.cos(pos2[0] * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // Start character movement
        function startMovement() {
            if (gameState.isMoving) return;
            
            gameState.isMoving = true;
            // document.getElementById('travelStatus').style.display = 'block';
            
            gameState.journeyData = {
                startPosition: [...gameState.currentPosition],
                totalDistance: calculateDistance(gameState.currentPosition, gameState.destination),
                distanceTraveled: 0,
                eventCounter: 0
            };
            
            const baseSpeed = gameState.character.speed * 2; 
            
            updateTravelInfo(gameState.journeyData.totalDistance, gameState.journeyData.distanceTraveled);
            
            gameState.moveInterval = setInterval(() => {
                const stepDistance = Math.min(baseSpeed, gameState.journeyData.totalDistance - gameState.journeyData.distanceTraveled);
                
                const progress = (gameState.journeyData.distanceTraveled + stepDistance) / gameState.journeyData.totalDistance;
                const newLat = gameState.journeyData.startPosition[0] + (gameState.destination[0] - gameState.journeyData.startPosition[0]) * progress;
                const newLng = gameState.journeyData.startPosition[1] + (gameState.destination[1] - gameState.journeyData.startPosition[1]) * progress;
                
                gameState.characterMarker.setLatLng([newLat, newLng]);
                gameState.journeyData.distanceTraveled += stepDistance;
                
                updateTravelInfo(gameState.journeyData.totalDistance, gameState.journeyData.distanceTraveled);
                
                gameState.journeyData.eventCounter++;

                if (updateActiveEffectsDuration()) { 
                    window.applyCharacterStatModifiers(); 
                }

                if (gameState.journeyData.eventCounter >= Math.max(3, Math.floor(20 / (gameState.character.speed || 1))) && Math.random() < 0.4) {
                    gameState.journeyData.eventCounter = 0;
                    pauseMovement();
                    triggerRandomEvent(); 
                    return;
                }
                
                if (gameState.journeyData.distanceTraveled >= gameState.journeyData.totalDistance) {
                    completeMovement();
                }
            }, 1000);
        }

        // Update travel information display
        function updateTravelInfo(totalDistance, distanceTraveled) {
            const progress = (distanceTraveled / totalDistance) * 100;
            let travelText = `Distance: ${distanceTraveled.toFixed(0)}/${totalDistance.toFixed(0)} m`;
            
            document.getElementById('travelInfo').textContent = travelText;
            document.getElementById('progressFill').style.width = progress + '%';

            // New line to update Distance tab:
            const currentJourneyDisplay = document.getElementById('currentJourneyDistanceDisplay');
            if (currentJourneyDisplay) {
                currentJourneyDisplay.textContent = `Current Journey: ${distanceTraveled.toFixed(0)} m / ${totalDistance.toFixed(0)} m`;
            }
        }
        
        // Called during movement to update effect durations
        function updateActiveEffectsDuration() {
            if (!gameState.character || !gameState.character.activeEffects || gameState.character.activeEffects.length === 0) return false;

            let effectsChanged = false;
            for (let i = gameState.character.activeEffects.length - 1; i >= 0; i--) {
                const effect = gameState.character.activeEffects[i];
                effect.duration--;
                if (effect.duration <= 0) {
                    addEventLog(`The effects of ${effect.description} have worn off.`);
                    gameState.character.activeEffects.splice(i, 1);
                    effectsChanged = true;
                }
            }
            return effectsChanged;
        }

        // Pause movement (for events)
        function pauseMovement() {
            if (gameState.moveInterval) {
                clearInterval(gameState.moveInterval);
                gameState.moveInterval = null;
            }
        }

        // Resume movement after event
        function resumeMovement() {
            if (gameState.isMoving && !gameState.moveInterval && gameState.destination && gameState.journeyData) {
                const baseSpeed = gameState.character.speed * 2; 
                
                gameState.moveInterval = setInterval(() => {
                    const stepDistance = Math.min(baseSpeed, gameState.journeyData.totalDistance - gameState.journeyData.distanceTraveled);
                    
                    const progress = (gameState.journeyData.distanceTraveled + stepDistance) / gameState.journeyData.totalDistance;
                    const newLat = gameState.journeyData.startPosition[0] + (gameState.destination[0] - gameState.journeyData.startPosition[0]) * progress;
                    const newLng = gameState.journeyData.startPosition[1] + (gameState.destination[1] - gameState.journeyData.startPosition[1]) * progress;
                    
                    gameState.characterMarker.setLatLng([newLat, newLng]);
                    gameState.journeyData.distanceTraveled += stepDistance;
                    
                    updateTravelInfo(gameState.journeyData.totalDistance, gameState.journeyData.distanceTraveled);
                    
                    gameState.journeyData.eventCounter++;

                    if (updateActiveEffectsDuration()) { 
                         window.applyCharacterStatModifiers(); 
                    }

                    if (gameState.journeyData.eventCounter >= Math.max(3, Math.floor(20 / (gameState.character.speed || 1))) && Math.random() < 0.4) {
                        gameState.journeyData.eventCounter = 0;
                        pauseMovement();
                        triggerRandomEvent(); 
                        return;
                    }
                    
                    if (gameState.journeyData.distanceTraveled >= gameState.journeyData.totalDistance) {
                        completeMovement();
                    }
                }, 1000);
            }
        }

        // Complete movement
        function completeMovement() {
            gameState.isMoving = false;
            pauseMovement();
            
            gameState.currentPosition = [...gameState.destination];
            gameState.destination = null;
            gameState.journeyData = null; 
            
            if (gameState.destinationMarker) {
                gameState.map.removeLayer(gameState.destinationMarker);
                gameState.destinationMarker = null;
            }
            
            // document.getElementById('travelStatus').style.display = 'none';
            addEventLog("üéØ Reached your destination! Click somewhere new to continue exploring.");
            
            saveCharacterData();
            window.updateDistanceTabDisplay(); 
        }

        // Cancel travel
        window.cancelTravel = function() {
            gameState.isMoving = false;
            pauseMovement();
            
            if (gameState.destinationMarker) {
                gameState.map.removeLayer(gameState.destinationMarker);
                gameState.destinationMarker = null;
            }
            
            gameState.destination = null;
            gameState.journeyData = null; 
            // document.getElementById('travelStatus').style.display = 'none';
            addEventLog("üõë Journey cancelled. Ready for a new adventure!");
            window.updateDistanceTabDisplay(); 
        };

        // Trigger random event
        function triggerRandomEvent() {
            let currentTerrain = gameState.currentTerrainType || 'plains'; 
            let filteredEvents = eventTemplates.filter(event => {
                return !event.requiredTerrain || event.requiredTerrain.length === 0 || event.requiredTerrain.includes(currentTerrain);
            });

            if (filteredEvents.length === 0) {
                filteredEvents = eventTemplates.filter(event => !event.requiredTerrain || event.requiredTerrain.length === 0);
                if (filteredEvents.length === 0) {
                     console.warn("No suitable events found for terrain:", currentTerrain, "and no generic events available.");
                     return; 
                }
            }
            
            if (filteredEvents.length > 0) { 
                const event = filteredEvents[Math.floor(Math.random() * filteredEvents.length)];
                showEventModal(event);
            } else {
                console.warn("No events available to trigger after filtering for terrain:", currentTerrain);
            }
        }

        // Show event modal
        function showEventModal(event) {
            document.getElementById('eventTitle').textContent = event.title;
            document.getElementById('eventDescription').textContent = event.description;
            
            const choicesContainer = document.getElementById('eventChoices');
            choicesContainer.innerHTML = '';
            
            event.choices.forEach((choice, index) => {
                const button = document.createElement('button');
                button.className = 'choice-btn';
                button.textContent = choice.text;
                button.onclick = () => handleEventChoice(event, choice);
                choicesContainer.appendChild(button);
            });
            
            document.getElementById('eventModal').style.display = 'flex';
        }

        // Handle event choice
        function handleEventChoice(event, choice) {
            let result = choice.success;
            let goldChange = choice.reward || 0;
            
            let successfulOutcome = true; 
            if (choice.stat) {
                const statValue = gameState.character[choice.stat];
                const difficulty = 5 + Math.floor(Math.random() * 5) + Math.floor((statValue || 0) / 2); 
                const roll = Math.floor(Math.random() * 20) + 1; 
                
                let currentStatValue = statValue || 0;
                if (['woodcutting', 'mining', 'fishing'].includes(choice.stat) && currentStatValue === 0) {
                    currentStatValue = -5; 
                }

                if (roll + currentStatValue < difficulty) {
                    successfulOutcome = false;
                    result = choice.fail || "Nothing happens.";
                    goldChange = choice.penalty || 0;
                }
            } else if (choice.goldCost) {
                if (gameState.character.gold < choice.goldCost) {
                    successfulOutcome = false; 
                    result = "You don't have enough gold!";
                    goldChange = 0;
                }
            }
            
            if (choice.goldCost && successfulOutcome) { 
                 gameState.character.gold -= choice.goldCost;
                 goldChange = 0; 
            } else if (goldChange !== 0) { 
                 gameState.character.gold = Math.max(0, gameState.character.gold + goldChange);
            }
            
            if (choice.statBonus && successfulOutcome) {
                Object.keys(choice.statBonus).forEach(stat => {
                    gameState.character.baseStats[stat] = (gameState.character.baseStats[stat] || 0) + choice.statBonus[stat]; 
                });
            }

            let itemObjectToGrant = null;
            let itemNameObtained = null; 

            if (successfulOutcome && choice.item && typeof choice.item === 'object' && !choice.action) { 
                itemObjectToGrant = { 
                    ...choice.item, 
                    id: 'item_direct_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    quantity: choice.item.quantity || 1
                };
                itemNameObtained = choice.item.name;
            } else if (!successfulOutcome && choice.failItem && typeof choice.failItem === 'object' && !choice.action) {
                 itemObjectToGrant = {
                    ...choice.failItem,
                    id: 'item_fail_direct_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    quantity: choice.failItem.quantity || 1
                };
                itemNameObtained = choice.failItem.name;
            }
             else if (successfulOutcome && typeof choice.item === 'string' && !choice.action) { 
                console.warn("Legacy string item grant used for:", choice.item); 
                itemObjectToGrant = { id: 'item_legacy_str_' + Date.now()  + '_' + Math.random().toString(36).substr(2, 9), name: choice.item, type: "misc", description: "An item.", effects: {}, usable: false, quantity: 1 };
                itemNameObtained = choice.item;
            }

            let actionMessage = "";
            if (successfulOutcome) { 
                if (typeof choice.action === 'function') {
                    const actionResult = choice.action(gameState.character); 
                    if (actionResult) { 
                        actionMessage = " " + actionResult; 
                    }
                }
            }
            
            if (itemObjectToGrant) {
                 if (!gameState.character.inventory) gameState.character.inventory = [];
                 gameState.character.inventory.push(itemObjectToGrant);
                 updateInventoryDisplay();
                 if (successfulOutcome) {
                     result += ` You obtained: ${itemNameObtained}!`;
                 } else { 
                     if (!choice.fail) { 
                        result = `You failed, but found ${itemNameObtained}.`;
                     } else { 
                        result += ` You obtained: ${itemNameObtained}.`;
                     }
                 }
            }

            result += actionMessage; 
            
            addEventLog(`‚öîÔ∏è ${event.title}: ${result}`);
            document.getElementById('eventModal').style.display = 'none';
            
            window.applyCharacterStatModifiers(); 
            saveCharacterData();

            if (typeof window.updatePetDisplay === 'function') {
                window.updatePetDisplay(); 
            }
            
            if (gameState.isMoving) {
                resumeMovement();
            }
        }

        // Add event to log
        function addEventLog(message) {
            const logContainer = document.getElementById('eventLogContent');
            const entry = document.createElement('div');
            entry.className = 'event-entry';
            entry.textContent = message;
            logContainer.appendChild(entry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            while (logContainer.children.length > 10) {
                logContainer.removeChild(logContainer.firstChild);
            }
        }

        // Update character display
        function updateCharacterDisplay() {
            if (!gameState.character) return;
            document.getElementById('characterName').textContent = gameState.character.name;
            document.getElementById('speedStat').textContent = gameState.character.speed;
            document.getElementById('combatStat').textContent = gameState.character.combat;
            document.getElementById('magicStat').textContent = gameState.character.magic;
            document.getElementById('luckStat').textContent = gameState.character.luck;
            document.getElementById('strengthStat').textContent = gameState.character.strength || 0; 
            document.getElementById('goldStat').textContent = gameState.character.gold;
            document.getElementById('healthStat').textContent = gameState.character.health;
            document.getElementById('maxHealthStat').textContent = gameState.character.maxHealth;
            document.getElementById('woodcuttingStat').textContent = gameState.character.woodcutting;
            document.getElementById('miningStat').textContent = gameState.character.mining;
            document.getElementById('fishingStat').textContent = gameState.character.fishing;
        }

        // Save character data
        async function saveCharacterData() {
            if (window.auth.currentUser && gameState.character) {
                gameState.character.position = gameState.currentPosition;
                await window.firebase.saveCharacter(gameState.character);
            } else {
                console.warn("saveCharacterData: No current user or character data to save.");
            }
        }

        // Create new character
        window.createCharacter = async function() {
            document.getElementById('authError').textContent = '';
            const username = document.getElementById('usernameInput').value.trim();
            const email = document.getElementById('emailInput').value.trim();
            const password = document.getElementById('passwordInput').value;
            const confirmPassword = document.getElementById('confirmPasswordInput').value;

            if (!username || !email || !password || password !== confirmPassword || !email.includes('@')) {
                alert('Please fill all fields correctly. Passwords must match and email must be valid.');
                return;
            }

            try {
                const userCredential = await window.firebaseAuthFunctions.createUserWithEmailAndPassword(auth, email, password);
                gameState.currentUser = userCredential.user.uid; 
                console.log("User account created with UID:", gameState.currentUser);

                const spawnInputOriginal = document.getElementById('spawnLocationInput').value.trim();
                const spawnInput = spawnInputOriginal.toLowerCase();
            
                let startPosition;
                let spawnMessage = "";
                let determinedTerrain = 'plains'; 

                const predefinedLocations = {
                    "london": { coords: [51.505, -0.09], terrain: 'urban' },
                    "whispering forest": { coords: [51.520, -0.100], terrain: 'forest' },
                    "dragon's peak": { coords: [51.480, -0.050], terrain: 'mountains' },
                    "serene coastline": { coords: [51.500, -0.150], terrain: 'coastline' }
                };

                const randomSpawn = () => {
                    return [
                        parseFloat((Math.random() * (51.55 - 51.45) + 51.45).toFixed(5)),
                        parseFloat((Math.random() * (-0.04 - (-0.14)) + (-0.14)).toFixed(5))
                    ];
                };

                if (predefinedLocations[spawnInput]) {
                    startPosition = predefinedLocations[spawnInput].coords;
                    determinedTerrain = predefinedLocations[spawnInput].terrain;
                    spawnMessage = `Spawning you in ${spawnInputOriginal} (${determinedTerrain}).`;
                } else if (spawnInput === "random" || spawnInput === "") {
                    startPosition = randomSpawn();
                    determinedTerrain = 'plains'; 
                    spawnMessage = "Spawning you at a random location (plains).";
                } else {
                    try {
                        const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(spawnInputOriginal)}&limit=1`);
                        if (response.ok) {
                            const data = await response.json();
                            if (data && data.length > 0 && data[0].lat && data[0].lon) {
                                startPosition = [parseFloat(data[0].lat), parseFloat(data[0].lon)];
                                determinedTerrain = 'plains'; 
                                spawnMessage = `Successfully found coordinates for '${spawnInputOriginal}'. Spawning you there (assumed plains).`;
                            } else {
                                startPosition = randomSpawn();
                                determinedTerrain = 'plains';
                                spawnMessage = `Could not find coordinates for '${spawnInputOriginal}'. Spawning you at a random location (plains) instead.`;
                            }
                        } else {
                            startPosition = randomSpawn();
                            determinedTerrain = 'plains';
                            spawnMessage = `Error looking up '${spawnInputOriginal}'. Spawning you at a random location (plains) instead.`;
                        }
                    } catch (error) {
                        console.error("Geocoding error:", error);
                        startPosition = randomSpawn();
                        determinedTerrain = 'plains';
                        spawnMessage = `Error during address lookup. Spawning you at a random location (plains) instead.`;
                    }
                }
            
                gameState.currentTerrainType = determinedTerrain; 

                gameState.character = {
                    name: username,
                    speed: 8 + Math.floor(Math.random() * 5),
                    combat: 8 + Math.floor(Math.random() * 5),
                    magic: 8 + Math.floor(Math.random() * 5),
                    luck: 8 + Math.floor(Math.random() * 5),
                    strength: 0, 
                    health: 100,
                    maxHealth: 100,
                    gold: 50,
                    position: startPosition, 
                    inventory: [], 
                    pets: [], 
                    activeEffects: [], 
                    woodcutting: 1, 
                    mining: 1,      
                    fishing: 1,
                    lifetimeDistance: 0 
                };
                
                gameState.character.inventory.push({
                    id: 'item_hp_create_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    name: "Health Potion",
                    type: "potion",
                    description: "Restores 25 health.",
                    effects: { health: 25 },
                    usable: true,
                    quantity: 1
                });
            
                gameState.character.baseStats = {
                    speed: gameState.character.speed,
                    combat: gameState.character.combat,
                    magic: gameState.character.magic,
                    luck: gameState.character.luck,
                    strength: gameState.character.strength,
                    maxHealth: gameState.character.maxHealth, 
                    woodcutting: gameState.character.woodcutting,
                    mining: gameState.character.mining,
                    fishing: gameState.character.fishing
                };
                gameState.character.activePetId = null; 
            
                gameState.currentPosition = gameState.character.position;
            
                await saveCharacterData(); 
                addEventLog(spawnMessage);

                try {
                    await window.firebaseAuthFunctions.sendEmailVerification(auth.currentUser);
                    document.getElementById('authError').textContent = 'Registration successful! Verification email sent.';
                } catch (verificationError) {
                    console.error("Error sending verification email:", verificationError);
                    document.getElementById('authError').textContent = 'Registration successful, but failed to send verification email.';
                }

                startGame();

            } catch (error) {
                console.error("Error creating account:", error);
                handleAuthError(error, 'authError');
            }
        };

        // Load existing character
        window.loadCharacter = async function() {
            document.getElementById('authError').textContent = '';
            const email = document.getElementById('emailInput').value.trim();
            const password = document.getElementById('passwordInput').value;
            const rememberMe = document.getElementById('rememberMeCheckbox').checked;
            console.log("Remember me checked: " + rememberMe);

            if (!email || !password) {
                alert('Please enter your email and password!');
                return;
            }

            try {
                const userCredential = await window.firebaseAuthFunctions.signInWithEmailAndPassword(auth, email, password);
                gameState.currentUser = userCredential.user.uid; 
                console.log("User signed in with UID:", gameState.currentUser);

                const characterData = await window.firebase.loadCharacter(); 

                if (characterData) {
                    console.log('Loaded character data. Raw health:', characterData.health, 'Raw maxHealth:', characterData.maxHealth);
                    
                    if (!characterData.inventory) {
                        characterData.inventory = [];
                        characterData.inventory.push({
                            id: 'item_hp_load_init_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                            name: "Health Potion", type: "potion", description: "Restores 25 health.",
                            effects: { health: 25 }, usable: true, quantity: 1
                        });
                    } else {
                        characterData.inventory = characterData.inventory.map(item => {
                            if (typeof item === 'string') {
                                if (item === "Mystic Compass") {
                                    return {
                                        id: 'item_mc_migrated_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                                        name: "Mystic Compass", type: "tool", description: "Helps navigate mysterious places.",
                                        effects: {}, usable: false, quantity: 1
                                    };
                                }
                                return { 
                                    id: 'item_str_migrated_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                                    name: item, type: "unknown", description: "An old item.",
                                    effects: {}, usable: false, quantity: 1
                                };
                            }
                            if (!item.id) item.id = 'item_obj_migrated_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                            if (item.quantity === undefined) item.quantity = 1;
                            if (item.usable === undefined) item.usable = (item.name === "Health Potion");
                            if (!item.type) item.type = (item.name === "Health Potion") ? "potion" : "misc";
                            if (!item.description) item.description = (item.name === "Health Potion") ? "Restores some health." : "An item.";
                            if (!item.effects) item.effects = (item.name === "Health Potion") ? { health: 25 } : {};
                            return item;
                        });
                        const hasHealthPotion = characterData.inventory.some(item => item.name === "Health Potion" && typeof item === 'object');
                        if (!hasHealthPotion) {
                            characterData.inventory.push({
                                id: 'item_hp_load_ensure_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                                name: "Health Potion", type: "potion", description: "Restores 25 health.",
                                effects: { health: 25 }, usable: true, quantity: 1
                            });
                        }
                    }

                    if (!characterData.pets) characterData.pets = [];
                    else {
                        characterData.pets.forEach(pet => {
                            if (pet.variation === undefined) pet.variation = null;
                            if (pet.equippedItem === undefined) pet.equippedItem = null; 
                        });
                    }
                    if (characterData.woodcutting === undefined) characterData.woodcutting = 1;
                    if (characterData.mining === undefined) characterData.mining = 1;
                    if (characterData.fishing === undefined) characterData.fishing = 1;
                    characterData.strength = characterData.strength || 0; 
                    if (!characterData.activeEffects) characterData.activeEffects = []; 
                    
                    if (typeof characterData.health === 'undefined') characterData.health = 100;
                    if (typeof characterData.maxHealth === 'undefined') characterData.maxHealth = 100;
                    if (typeof characterData.lifetimeDistance === 'undefined') {
                        characterData.lifetimeDistance = 0;
                    }
                    
                    gameState.character = characterData; 
                    console.log('Character data after defaulting. Health:', gameState.character.health, 'Max Health:', gameState.character.maxHealth);

                    if (!characterData.baseStats) {
                        characterData.baseStats = {
                            speed: characterData.speed, combat: characterData.combat, magic: characterData.magic,
                            luck: characterData.luck, strength: characterData.strength, maxHealth: characterData.maxHealth,
                            woodcutting: characterData.woodcutting, mining: characterData.mining, fishing: characterData.fishing
                        };
                    }
                     if (characterData.baseStats.strength === undefined) {
                        characterData.baseStats.strength = characterData.strength || 0;
                    }
                    if (characterData.baseStats.maxHealth === undefined) {
                        characterData.baseStats.maxHealth = characterData.maxHealth || 100;
                    }
                    
                    gameState.character.activePetId = characterData.activePetId || null; 
                    gameState.currentPosition = characterData.position || [51.505, -0.09]; 
                    
                    startGame();
                } else {
                    document.getElementById('authError').textContent = 'Login successful, but no character data found.';
                    gameState.currentUser = null; 
                    await window.firebaseAuthFunctions.signOut(window.auth); 
                    console.log("User signed out as no character data was found.");
                }

            } catch (error) {
                console.error("Error signing in:", error);
                handleAuthError(error, 'authError');
            }
        };
        
        function handleAuthError(error, errorElementId) {
            const errorDiv = document.getElementById(errorElementId);
            if (!errorDiv) return; 

            console.error("Auth Error Code:", error.code); 

            switch (error.code) {
                case 'auth/email-already-in-use':
                    errorDiv.textContent = 'This email address is already in use.';
                    break;
                case 'auth/invalid-email':
                    errorDiv.textContent = 'The email address is not valid.';
                    break;
                case 'auth/weak-password':
                    errorDiv.textContent = 'The password is too weak (at least 6 characters).';
                    break;
                case 'auth/user-not-found':
                    errorDiv.textContent = 'No account found with this email.';
                    break;
                case 'auth/wrong-password':
                    errorDiv.textContent = 'Incorrect password.';
                    break;
                case 'auth/too-many-requests':
                    errorDiv.textContent = 'Too many login attempts. Try again later or reset password.';
                    break;
                case 'auth/operation-not-allowed':
                    errorDiv.textContent = 'Email/Password sign-in is not enabled.';
                    break;
                default:
                    errorDiv.textContent = 'Authentication error. Please try again.'; 
                    break;
            }
        }
        
        window.logoutCharacter = async function() {
            try {
                await window.firebaseAuthFunctions.signOut(window.auth);
                console.log("User signed out successfully.");
                gameState.currentUser = null;
                gameState.character = null;
                
                if (gameState.map) {
                    gameState.map.remove();
                    gameState.map = null;
                }
                gameState.characterMarker = null;
                gameState.destinationMarker = null;
                if (gameState.moveInterval) clearInterval(gameState.moveInterval);
                gameState.isMoving = false;
                gameState.destination = null;
                gameState.journeyData = null;
                document.getElementById('travelStatus').style.display = 'none';

                document.getElementById('loginPanel').style.display = 'block';
                document.getElementById('gameContainer').style.display = 'none';
                
                const logContainer = document.getElementById('eventLogContent');
                if (logContainer) logContainer.innerHTML = ''; 
                addEventLog("üö™ You have been successfully logged out. See you next time, adventurer!");
                const usernameInput = document.getElementById('usernameInput');
                if(usernameInput) usernameInput.value = '';

            } catch (error) {
                console.error("Error signing out:", error);
                alert("Error signing out: " + error.message);
            }
        };

        // Start the game
        function startGame() {
            if (!window.auth.currentUser || !gameState.character) {
                alert("Error: Not properly logged in or character data missing. Please log in again.");
                document.getElementById('loginPanel').style.display = 'block';
                document.getElementById('gameContainer').style.display = 'none';
                if (gameState.map) { 
                    gameState.map.remove();
                    gameState.map = null;
                }
                return;
            }

            document.getElementById('loginPanel').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'flex'; 
            
            window.applyCharacterStatModifiers(); 
            
            if (!gameState.map) {
                initMap(); 
            } else {
                if (gameState.characterMarker) {
                    gameState.characterMarker.setLatLng(gameState.currentPosition).bindPopup("üßô‚Äç‚ôÇÔ∏è " + gameState.character.name);
                } else { 
                    const characterIcon = L.divIcon({ className: 'character-marker', iconSize: [30, 30] });
                    gameState.characterMarker = L.marker(gameState.currentPosition, { icon: characterIcon })
                        .addTo(gameState.map)
                        .bindPopup("üßô‚Äç‚ôÇÔ∏è " + gameState.character.name);
                }
                gameState.map.setView(gameState.currentPosition, gameState.map.getZoom() || 18); 
            }

            if (!gameState.currentTerrainType || gameState.currentTerrainType === 'plains') { 
                const pos = gameState.currentPosition;
                let foundKnownLocation = false;
                const predefinedLocations = {
                    "london": { coords: [51.505, -0.09], terrain: 'urban' },
                    "whispering forest": { coords: [51.520, -0.100], terrain: 'forest' },
                    "dragon's peak": { coords: [51.480, -0.050], terrain: 'mountains' },
                    "serene coastline": { coords: [51.500, -0.150], terrain: 'coastline' }
                };
                for (const key in predefinedLocations) {
                    if (predefinedLocations[key].coords[0] === pos[0] && predefinedLocations[key].coords[1] === pos[1]) {
                        gameState.currentTerrainType = predefinedLocations[key].terrain;
                        foundKnownLocation = true;
                        break;
                    }
                }
                if (!foundKnownLocation) {
                    gameState.currentTerrainType = 'plains';
                }
            }
             if (typeof gameState.currentTerrainType === 'undefined') {
                gameState.currentTerrainType = 'plains'; 
            }
            
            addEventLog(`üåü Welcome, ${gameState.character.name}! Your current terrain is ${gameState.currentTerrainType}. Your adventure begins/continues...`);
            updateInventoryDisplay(); 
            window.openTab('character'); 
            window.updatePetDisplay(); 
            window.updateDistanceTabDisplay(); 
        }

        window.damagePlayer = function(amount) {
            if (!gameState.character) return;
            gameState.character.health = Math.max(0, gameState.character.health - amount);
            updateCharacterDisplay(); 
            addEventLog(`üí• You took ${amount} damage!`);
            if (gameState.character.health === 0) {
                addEventLog("üíÄ You have fallen!");
            }
            saveCharacterData();
        };

        window.healPlayer = function(amount) {
            if (!gameState.character) return;
            gameState.character.health = Math.min(gameState.character.maxHealth, gameState.character.health + amount);
            updateCharacterDisplay(); 
            addEventLog(`üíö You healed for ${amount} health!`);
            saveCharacterData();
        };

        function updateInventoryDisplay() {
            const inventoryContent = document.getElementById('inventoryContent');
            if (!inventoryContent) {
                console.warn("updateInventoryDisplay called but inventoryContent (target for items) not found.");
                return;
            }
            inventoryContent.innerHTML = ''; 

            if (gameState.character && gameState.character.inventory && gameState.character.inventory.length > 0) {
                gameState.character.inventory.forEach(item => {
                    if (typeof item !== 'object' || item === null) { 
                        console.warn("Invalid item found in inventory:", item);
                        return; 
                    }

                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'inventory-item'; 
                    itemDiv.style.display = 'flex'; 
                    itemDiv.style.justifyContent = 'space-between'; 
                    itemDiv.style.alignItems = 'center'; 
                    itemDiv.style.padding = '5px 0'; 
                    itemDiv.style.borderBottom = '1px solid #444'; 

                    const itemNameSpan = document.createElement('span');
                    itemNameSpan.textContent = `${item.name} (Qty: ${item.quantity || 1})`;
                    itemNameSpan.title = item.description || "No description available."; 
                    itemDiv.appendChild(itemNameSpan);

                    if (item.usable) {
                        const useButton = document.createElement('button');
                        useButton.textContent = 'Use';
                        useButton.style.marginLeft = '10px'; 
                        useButton.style.padding = '3px 8px'; 
                        useButton.style.fontSize = '0.9em';
                        const useButton = document.createElement('button');
                        useButton.style.marginLeft = '10px'; 
                        useButton.style.padding = '3px 8px'; 
                        useButton.style.fontSize = '0.9em';
                        useButton.className = 'choice-btn'; 

                        if (item.equipableToPet === true) {
                            useButton.textContent = 'Equip to Pet';
                            useButton.onclick = function() { window.equipItemToPet(item.id); };
                        } else {
                            useButton.textContent = 'Use';
                            useButton.onclick = function() { window.useItem(item.id); };
                        }
                        itemDiv.appendChild(useButton);
                    } else if (item.equipableToPet === true) { // Item is equipable but not usable by player
                        const equipButton = document.createElement('button');
                        equipButton.textContent = 'Equip to Pet';
                        equipButton.style.marginLeft = '10px';
                        equipButton.style.padding = '3px 8px';
                        equipButton.style.fontSize = '0.9em';
                        equipButton.className = 'choice-btn';
                        equipButton.onclick = function() { window.equipItemToPet(item.id); };
                        itemDiv.appendChild(equipButton);
                    }
                    inventoryContent.appendChild(itemDiv);
                });
            } else {
                const noItemsDiv = document.createElement('div');
                noItemsDiv.className = 'inventory-item'; 
                noItemsDiv.textContent = 'Your backpack is empty.';
                inventoryContent.appendChild(noItemsDiv);
            }
        }

        window.useItem = function(itemId) {
            if (!gameState.character || !gameState.character.inventory) {
                console.warn("useItem called but character or inventory not found.");
                return;
            }

            const itemIndex = gameState.character.inventory.findIndex(item => item && item.id === itemId);
            if (itemIndex === -1) {
                console.warn("Attempted to use item not found in inventory with ID:", itemId);
                addEventLog("Error: Could not find that item.");
                return;
            }

            const item = gameState.character.inventory[itemIndex];

            if (!item.usable) {
                addEventLog(`Cannot use ${item.name}.`);
                return;
            }

            let effectApplied = false;
            let effectMessage = "";

            if (item.effects) {
                if (item.effects.health) {
                    const healthBefore = gameState.character.health;
                    if (healthBefore < gameState.character.maxHealth) {
                        window.healPlayer(item.effects.health); 
                        const healthAfter = gameState.character.health;
                        const healedAmount = healthAfter - healthBefore;
                        effectMessage = `Restored ${healedAmount} health.`;
                        effectApplied = true;
                    } else {
                        effectMessage = "You are already at full health.";
                        effectApplied = false; 
                    }
                }
            }

            if (effectApplied) {
                 item.quantity = (item.quantity || 1) - 1; 
                 if (item.quantity <= 0) {
                    gameState.character.inventory.splice(itemIndex, 1); 
                 }
                 addEventLog(`Used ${item.name}. ${effectMessage}`);
            } else if (effectMessage) { 
                addEventLog(`${item.name} had no effect. ${effectMessage}`);
            } else {
                 addEventLog(`You examine ${item.name}, but it has no usable effect right now.`); 
            }
            
            updateInventoryDisplay(); 
            window.applyCharacterStatModifiers(); 
            saveCharacterData(); 
        };

        window.equipItemToPet = function(itemId) {
            if (!gameState.character || !gameState.character.inventory) {
                console.error("equipItemToPet: Character or inventory not found.");
                addEventLog("Error: Character data or inventory missing.");
                return;
            }

            const itemIndex = gameState.character.inventory.findIndex(invItem => invItem && invItem.id === itemId);
            if (itemIndex === -1) {
                console.error("equipItemToPet: Item not found in inventory with ID:", itemId);
                addEventLog("Error: Could not find that item in your inventory.");
                return;
            }
            const item = gameState.character.inventory[itemIndex];

            if (!gameState.character.activePetId) {
                addEventLog("Please select an active pet first to equip an item.");
                return;
            }

            const activePet = gameState.character.pets.find(p => p.id === gameState.character.activePetId);
            if (!activePet) {
                console.error("equipItemToPet: Active pet not found with ID:", gameState.character.activePetId);
                addEventLog("Active pet not found. Cannot equip item.");
                return;
            }

            // Handle Currently Equipped Item
            if (activePet.equippedItem) {
                const previouslyEquippedItem = activePet.equippedItem;
                gameState.character.inventory.push(previouslyEquippedItem); // Add it back to inventory
                addEventLog(`Unequipped ${previouslyEquippedItem.name} from ${activePet.name} and returned it to inventory.`);
                activePet.equippedItem = null; // Clear old item from pet
            }

            // Equip New Item
            activePet.equippedItem = item;
            gameState.character.inventory.splice(itemIndex, 1); // Remove item from inventory

            addEventLog(`Equipped ${item.name} to ${activePet.name}.`);

            // Update Game State
            window.applyCharacterStatModifiers(); // Will need updates for pet stats
            updateInventoryDisplay();
            window.updatePetDisplay(); // Will need updates to show equipped item
            saveCharacterData();
        };

        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('forgotPasswordLink').addEventListener('click', function(event) {
                event.preventDefault(); 
                handlePasswordReset();
            });

            const tabButtons = document.querySelectorAll('#unifiedUIPanel .tab-button');
            tabButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const tabName = this.getAttribute('data-tab');
                    const unifiedUIPanel = document.getElementById('unifiedUIPanel');

                    if (this.classList.contains('active')) {
                        // Clicked on the already active tab, toggle collapse
                        unifiedUIPanel.classList.toggle('content-collapsed');
                        // If we are collapsing, ensure no tab content is displayed
                        if (unifiedUIPanel.classList.contains('content-collapsed')) {
                            const tabContents = document.querySelectorAll('#unifiedUIPanel .tab-content');
                            tabContents.forEach(content => {
                                content.style.display = 'none';
                            });
                        } else {
                            // If we are expanding, make sure the active tab's content is displayed
                            if (tabName) window.openTab(tabName);
                        }
                    } else {
                        // Clicked on a new tab
                        unifiedUIPanel.classList.remove('content-collapsed'); // Ensure content is expanded
                        if (tabName) {
                            window.openTab(tabName); // Switch to the new tab
                        }
                        // If it's a button without data-tab (like logout), it will be handled by its own onclick or other listeners.
                    }
                });
            });
            showLoginForm(); 
        });
        
        window.showRegisterForm = function() {
            document.getElementById('loginPanelTitle').textContent = 'üìú Register New Adventurer üìú';
            document.getElementById('registrationFields').style.display = 'block';
            document.getElementById('loginSpecificFields').style.display = 'none';
            document.getElementById('loginButton').style.display = 'none';
            document.getElementById('switchToRegisterButton').style.display = 'none';
            document.getElementById('completeRegisterButton').style.display = 'inline-block';
            document.getElementById('backToLoginButton').style.display = 'inline-block';
            document.getElementById('authError').textContent = '';
        }

        window.showLoginForm = function() {
            document.getElementById('loginPanelTitle').textContent = 'üó°Ô∏è Enter the Realm üó°Ô∏è';
            document.getElementById('registrationFields').style.display = 'none';
            document.getElementById('loginSpecificFields').style.display = 'block';
            document.getElementById('loginButton').style.display = 'inline-block';
            document.getElementById('switchToRegisterButton').style.display = 'inline-block';
            document.getElementById('completeRegisterButton').style.display = 'none';
            document.getElementById('backToLoginButton').style.display = 'none';
            document.getElementById('authError').textContent = '';
        }

        window.openTab = function(tabBaseName) {
           const unifiedUIPanel = document.getElementById('unifiedUIPanel');
           const tabContents = document.querySelectorAll('#unifiedUIPanel .tab-content'); 
           tabContents.forEach(content => {
               content.style.display = 'none';
           });

           const tabButtons = document.querySelectorAll('#unifiedUIPanel .tab-button'); 
           tabButtons.forEach(button => {
               button.classList.remove('active');
           });

           const selectedTabContentId = tabBaseName + "TabContent";
           const selectedTabContent = document.getElementById(selectedTabContentId);
           
           // Only display content if the panel is not collapsed
           if (selectedTabContent && !unifiedUIPanel.classList.contains('content-collapsed')) {
               selectedTabContent.style.display = 'block';
           }

           const activeButton = document.querySelector(`.tab-button[data-tab='${tabBaseName}']`);
           if (activeButton) {
               activeButton.classList.add('active');
           }
           if (tabBaseName === 'character') {
                updateActiveEffectsDisplay(); 
           }
           if (tabBaseName === 'distance') { 
               window.updateDistanceTabDisplay();
           }
       }

       function updateDistanceTabDisplay() {
            const currentJourneyDisplay = document.getElementById('currentJourneyDistanceDisplay');
            const lifetimeDisplay = document.getElementById('lifetimeDistanceDisplay');

            if (currentJourneyDisplay) {
                if (gameState.isMoving && gameState.journeyData) {
                    currentJourneyDisplay.textContent = `Current Journey: ${gameState.journeyData.distanceTraveled.toFixed(0)} m / ${gameState.journeyData.totalDistance.toFixed(0)} m`;
                } else {
                    currentJourneyDisplay.textContent = "Current Journey: N/A";
                }
            }

            if (lifetimeDisplay && gameState.character) {
                const lifetimeDist = gameState.character.lifetimeDistance || 0;
                lifetimeDisplay.textContent = `Lifetime Distance: ${lifetimeDist.toFixed(0)} m`;
            }
        }
        window.updateDistanceTabDisplay = updateDistanceTabDisplay;

       window.updatePetDisplay = function() {
           const petsContent = document.getElementById('petsTabContent');
           if (!petsContent) return; 

           petsContent.innerHTML = ''; 

           if (gameState.character && gameState.character.pets && gameState.character.pets.length > 0) {
               const petList = document.createElement('ul');
               petList.style.listStyleType = 'none'; 
               petList.style.padding = '0';

               gameState.character.pets.forEach(pet => {
                   const petItem = document.createElement('li');
                   petItem.style.padding = '5px 0';
                   petItem.style.borderBottom = '1px solid #444'; 
                   petItem.innerHTML = ''; 

                   const imagePath = petImageMapping[pet.type.toLowerCase()];
                   if (imagePath) {
                       const img = document.createElement('img');
                       img.src = imagePath;
                       img.style.width = '20px';
                       img.style.height = '20px';
                       img.style.marginRight = '8px';
                       img.style.verticalAlign = 'middle'; 
                       petItem.appendChild(img);
                   } else {
                       const iconSpan = document.createElement('span');
                       iconSpan.textContent = '‚ùì '; 
                       iconSpan.style.marginRight = '8px';
                       petItem.appendChild(iconSpan);
                   }

                   let displayName = pet.name;
                   petItem.style.color = ''; 
                   
                   if (pet.variation === 'shiny') {
                       displayName = `[Shiny] ${pet.name}`;
                   } else if (pet.variation === 'ghost') {
                       displayName = `[Ghost] ${pet.name}`;
                   }
                   
                   let statsText = " - Stats: LCK 0, STR 0, SPD 0"; 
                   if (pet.stats) {
                       statsText = ` - Stats: LCK ${pet.stats.luck || 0}, STR ${pet.stats.strength || 0}, SPD ${pet.stats.speed || 0}`;
                   }

                   const textSpan = document.createElement('span');
                   textSpan.textContent = `${displayName} (${pet.type})${statsText}`;
                   if (pet.variation === 'shiny') {
                       textSpan.style.color = '#FFD700';
                   } else if (pet.variation === 'ghost') {
                        const petImageElement = petItem.querySelector('img');
                        if(petImageElement) petImageElement.style.opacity = '0.7';
                   }
                   petItem.appendChild(textSpan);
                   
                   petItem.style.cursor = 'pointer'; 

                   if (gameState.character && pet.id === gameState.character.activePetId) {
                       petItem.style.backgroundColor = '#4a5d70'; 
                   } else {
                       petItem.style.backgroundColor = ''; 
                   }

                   // Display equipped item and unequip button
                   if (pet.equippedItem && pet.equippedItem.name) {
                       const equippedItemDiv = document.createElement('div');
                       equippedItemDiv.style.fontSize = '0.85em';
                       equippedItemDiv.style.color = '#bdc3c7'; // Lighter color for sub-info
                       equippedItemDiv.style.marginLeft = '25px'; // Indent under pet name
                       equippedItemDiv.textContent = `Equipped: ${pet.equippedItem.name}`;
                       petItem.appendChild(equippedItemDiv);

                       const unequipButton = document.createElement('button');
                       unequipButton.textContent = 'Unequip';
                       unequipButton.style.fontSize = '0.8em';
                       unequipButton.style.padding = '2px 5px';
                       unequipButton.style.marginLeft = '10px';
                       unequipButton.className = 'choice-btn'; // Re-use existing button style
                       unequipButton.onclick = function(event) {
                           event.stopPropagation(); // Prevent pet selection click when clicking unequip
                           window.unequipItemFromPet(pet.id);
                       };
                       equippedItemDiv.appendChild(unequipButton); // Append button next to item name
                   }

                   petItem.addEventListener('click', () => {
                       if (gameState.character) {
                           if (gameState.character.activePetId === pet.id) {
                               gameState.character.activePetId = null; 
                           } else {
                               gameState.character.activePetId = pet.id; 
                           }
                           window.updatePetDisplay(); 
                           window.applyCharacterStatModifiers(); 
                           saveCharacterData(); 
                       }
                   });

                   petList.appendChild(petItem);
               });
               petsContent.appendChild(petList);
           } else {
               petsContent.innerHTML = '<p>No loyal companions by your side... yet!</p>';
           }
       }

       window.unequipItemFromPet = function(petId) {
            if (!gameState.character || !gameState.character.pets || !gameState.character.inventory) {
                console.error("unequipItemFromPet: Critical data missing (character, pets, or inventory).");
                addEventLog("Error: Critical game data missing.");
                return;
            }

            const pet = gameState.character.pets.find(p => p.id === petId);
            if (!pet) {
                console.error("unequipItemFromPet: Pet not found with ID:", petId);
                addEventLog("Error: Could not find the specified pet.");
                return;
            }

            if (!pet.equippedItem) {
                addEventLog(`${pet.name} has no item equipped.`);
                return;
            }

            const itemToReturn = pet.equippedItem;
            gameState.character.inventory.push(itemToReturn);
            addEventLog(`Unequipped ${itemToReturn.name} from ${pet.name}. Item returned to inventory.`);

            pet.equippedItem = null;

            window.applyCharacterStatModifiers();
            updateInventoryDisplay();
            window.updatePetDisplay();
            saveCharacterData();
        };

       async function handlePasswordReset() {
            document.getElementById('authError').textContent = '';
            const email = prompt("Please enter your email address to reset your password:");

            if (!email || email.trim() === "") {
                document.getElementById('authError').textContent = 'Password reset cancelled or no email provided.';
                return;
            }

            try {
                await window.firebaseAuthFunctions.sendPasswordResetEmail(auth, email.trim());
                document.getElementById('authError').textContent = 'If an account exists for ' + email.trim() + ', a password reset email has been sent.';
            } catch (error) {
                console.error("Password reset error:", error);
                document.getElementById('authError').textContent = 'Error sending password reset email. Please ensure the email is correct or try again later.';
            }
        }

       window.applyActivePetStats = function() {
           if (!gameState.character || !gameState.character.baseStats) {
                console.warn("applyActivePetStats: Character or baseStats not found.");
                return;
           }
            gameState.character.luck = gameState.character.baseStats.luck;
            gameState.character.strength = gameState.character.baseStats.strength;
            gameState.character.speed = gameState.character.baseStats.speed;

            const activePetId = gameState.character.activePetId;
            if (activePetId && gameState.character.pets) {
                const activePet = gameState.character.pets.find(p => p.id === activePetId);
                if (activePet && activePet.stats) {
                    gameState.character.luck += (activePet.stats.luck || 0);
                    gameState.character.strength += (activePet.stats.strength || 0);
                    gameState.character.speed += (activePet.stats.speed || 0);

                    // Apply stats from equipped item
                    if (activePet.equippedItem && activePet.equippedItem.effects) {
                        console.log(`Applying stats from ${activePet.name}'s equipped item: ${activePet.equippedItem.name}`); // Optional: for debugging
                        for (const statEffect in activePet.equippedItem.effects) {
                            if (gameState.character.hasOwnProperty(statEffect)) {
                                gameState.character[statEffect] += activePet.equippedItem.effects[statEffect];
                                console.log(` > ${statEffect} increased by ${activePet.equippedItem.effects[statEffect]}`); // Optional
                            }
                        }
                    }
                }
            }
       };

       window.applyCharacterStatModifiers = function() {
           if (!gameState.character) return;

           if (!gameState.character.baseStats) {
               console.error("CRITICAL: baseStats missing on character object. Attempting to reinitialize.");
               gameState.character.baseStats = { 
                   speed: gameState.character.speed || 10, combat: gameState.character.combat || 10,
                   magic: gameState.character.magic || 10, luck: gameState.character.luck || 10,
                   strength: gameState.character.strength || 0, maxHealth: gameState.character.maxHealth || 100,
                   woodcutting: gameState.character.woodcutting || 1, mining: gameState.character.mining || 1,
                   fishing: gameState.character.fishing || 1
               };
           }

           Object.keys(gameState.character.baseStats).forEach(statKey => {
                if (statKey !== 'health') { 
                   gameState.character[statKey] = gameState.character.baseStats[statKey];
                }
           });
            
           window.applyActivePetStats(); 

           if (gameState.character.activeEffects && gameState.character.activeEffects.length > 0) {
               gameState.character.activeEffects.forEach(effect => {
                   if (gameState.character.hasOwnProperty(effect.stat)) {
                       gameState.character[effect.stat] += effect.amount;
                       if (effect.stat === 'speed' && gameState.character.speed < 1) gameState.character.speed = 1;
                       if (effect.stat === 'strength' && gameState.character.strength < 0) gameState.character.strength = 0; 
                       if (['luck', 'combat', 'magic'].includes(effect.stat) && gameState.character[effect.stat] < 0) {
                           gameState.character[effect.stat] = 0;
                       }
                       if (effect.stat === 'maxHealth' && gameState.character.maxHealth < 1) gameState.character.maxHealth = 1;
                   }
               });
           }
           
           gameState.character.health = Math.min(gameState.character.health, gameState.character.maxHealth);
           gameState.character.health = Math.max(0, gameState.character.health); 

           updateCharacterDisplay();
           updateActiveEffectsDisplay(); 
       };

       function updateActiveEffectsDisplay() {
            const effectsListDiv = document.getElementById('activeEffectsList');
            if (!effectsListDiv) return;

            effectsListDiv.innerHTML = ''; 

            if (gameState.character && gameState.character.activeEffects && gameState.character.activeEffects.length > 0) {
                gameState.character.activeEffects.forEach(effect => {
                    const effectDiv = document.createElement('div');
                    // Make the text slightly smaller for effects
                    effectDiv.style.fontSize = "0.9em"; 
                    effectDiv.style.marginTop = "3px"; // Add a little space between effects
                    effectDiv.textContent = `${effect.description} (${effect.stat}: ${effect.amount > 0 ? '+' : ''}${effect.amount}, Duration: ${effect.duration})`;
                    effectsListDiv.appendChild(effectDiv);
                });
            } else {
                const noEffectsDiv = document.createElement('div');
                noEffectsDiv.style.fontSize = "0.9em";
                noEffectsDiv.textContent = 'None';
                effectsListDiv.appendChild(noEffectsDiv);
            }
        }
        window.updateActiveEffectsDisplay = updateActiveEffectsDisplay; 
    </script>
</body>
</html>
